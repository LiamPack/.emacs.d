#+TITLE: My Emacs Config

Documenting this configuration is a way to consolidate the knowledge of my own
environment. This could serve as an entry-point for someone (bless their heart) to try to
see what this configuration has to offer, but primarily this is (somewhat
counter intuitively) for selfish reasons.

Outstanding things to do:
- [ ] Evaluate Tree-Sitter instead of font-lock for syntax highlighting
- [ ] update org-roam to v2

* sane defaults
Not all of the emacs defaults are quite sane. So here's to some sanity. This section is
long and needs to be broken up. Some sanity includes:
- high cap GC which doesn't intrude on user experience (=gcmh=)
- tramp
- buffer cleanup utility
- autosaving
- useful binds (ELisp evaluation)

#+begin_src emacs-lisp
;; prevent emacs-provided org from being loaded
(straight-register-package 'org)
(straight-register-package 'org-contrib)

;; hacky way to remove the =custom-variables= generation in =init.el=
(setq custom-file (make-temp-file "emacs-custom-"))

;; basics and better default
;; from https://pastebin.com/MDagsZD7
(use-package emacs
  :init
  ;; why does this bind exist
  (unbind-key (kbd "C-z") global-map)
  (unbind-key (kbd "C-x C-z") global-map)
  ;; minimizes GC interferecen with user activity
  (setq gc-cons-threshold (* 16 1024 1024))


  ;; i fat-finger way too much to not have the confirmation
  (setq confirm-kill-emacs #'yes-or-no-p)
  (global-hl-line-mode t)               ; highlight current line
  (setq-default fill-column 90)         ; column length
  (column-number-mode t)                ; show column number in the mode line

  ;; name on top of frame
  (setq-default frame-title-format '("%b [%m]"))

  (setq warning-minimum-level :error)   ;avoid warning buffer

  ;; scroll
  (setq auto-window-vscroll nil)  ; avoid next-line to trigger line-move-partial
  (setq scroll-conservatively 10)
  (setq scroll-margin 7)
  (menu-bar-mode -1)
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (when (fboundp 'set-horizontal-scroll-bar-mode)
    (set-horizontal-scroll-bar-mode nil))

  (setq mouse-wheel-scroll-amount '(3 ((shift) . 1) ((control) . nil)))
  (setq mouse-wheel-follow-mouse 't)
  (setq scroll-step 1)

  ;; other basiscs
  (setq ring-bell-function 'ignore)
  (setq inhibit-startup-screen t)

  ;; create backups in separate folder
  (setq backup-directory-alist `(("." . "~/.saves")))
  (setq create-lockfiles nil)           ; files with # problem with onedrive...

  ;; answering just 'y' or 'n' will do
  (defalias 'yes-or-no-p 'y-or-n-p)

  (if (display-graphic-p)
      (blink-cursor-mode 1)
    (progn
      (blink-cursor-mode -1)
      (setq visible-cursor nil)))

  (setq-default
   initial-scratch-message ";; Present Day
"
   visible-bell t
   create-lockfiles nil)

  (show-paren-mode t)
  (setq show-paren-style 'parenthesis)
  ;; do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  (setq-default
   indent-tabs-mode nil                 ; don't insert tab when indent
   ;; this is giving me problems when creating new lines in org-mode source blocks
   help-window-select t                 ; focus on help window when openend
   window-combination-resize t)

  (defun lp/clean-up-buffer-or-region ()
    "Untabifies, indents and deletes trailing whitespace from buffer or region."
    (interactive)
    (save-excursion
      (unless (region-active-p)
        (mark-whole-buffer))
      (untabify (region-beginning) (region-end))
      (indent-region (region-beginning) (region-end))
      (save-restriction
        (narrow-to-region (region-beginning) (region-end)) (delete-trailing-whitespace))))

  (define-key global-map (kbd "C-x k") #'(lambda () (interactive) (kill-buffer nil)))
  (define-key global-map (kbd "C-x K") #'(lambda () (interactive) (kill-buffer nil) (delete-window)))
  (define-key emacs-lisp-mode-map (kbd "C-c C-k") #'eval-buffer)
  (define-key global-map (kbd "C-c n") #'lp/clean-up-buffer-or-region)
  (define-key global-map (kbd "<f5>")  #'revert-buffer)

  (define-key global-map (kbd "M-z") #'zap-up-to-char) ;; i generally go up to a char non-inclusive
  (define-key global-map (kbd "M-Z") #'zap-to-char)

  (define-key global-map (kbd "C-<tab>") 'next-window-any-frame)
  (define-key global-map (kbd "<backtab>") 'previous-window-any-frame)
  (define-key global-map (kbd "C-x C-M-e") 'pp-macroexpand-last-sexp)
  (define-key global-map (kbd "C-x C-e") 'eval-defun)
  (define-key global-map (kbd "C-x e") 'eval-last-sexp)
  (define-key global-map (kbd "C-h j") 'describe-keymap)
  (define-key global-map (kbd "C-c C-j") 'join-line)
  (define-key global-map (kbd "C-S-p") #'(lambda () (interactive) (previous-line 7)))
  (define-key global-map (kbd "C-S-n") #'(lambda () (interactive) (next-line 7)))
  (use-package repeat
    :straight (:type built-in)
    :config
    (setq repeat-on-final-keystroke t)
    (setq set-mark-command-repeat-pop t)

    (repeat-mode 1))
  ) ; resize windows proportionaly

(use-package focus-autosave-mode        ; Save buffers when focus is lost
  :straight t
  :init (focus-autosave-mode)
  :diminish focus-autosave-mode)
#+end_src
** time on mode-line
#+begin_src emacs-lisp
(use-package time                       ; Show current time
  :straight t
  :config
  (setq display-time-world-time-format "%H:%M %Z, %d. %b"
        display-time-world-list '(("Europe/Berlin"    "Berlin")
                                  ("Europe/London"    "London")
                                  ("Europe/Istanbul"  "Istanbul")
                                  ("America/Winnipeg" "Winnipeg (CA)")
                                  ("America/New_York" "New York (USA)")
                                  ("Asia/Tokyo"       "Tokyo (JP)")))
  (setf display-time-default-load-average nil
        display-time-use-mail-icon t
        display-time-24hr-format t)
  (display-time-mode))
#+end_src
* aesthetics
** solid themes
General aesthetic configurations for emacs

#+begin_verse
  espresso ; cyberpunk ; moe-light ;
 * good themes
 ** base16
     * zenburn
     * unikitty light
     * solarized light
     * rebecca
     * porple
     * phd
     * ocean
     * nord
     * monokai
     * mocha
     * mellow-purple
     * material + material palenight
     * harmonic-{light,dark}
     * cupertino
     * cupcake
     * sulphurpool-light
     * heath-light
     * cave-light
     * classic-{dark,light}
  * avk-daylight

 * actual good themes
   * leuven / parchment (https://github.com/ajgrf/parchment)
   * porple
   * doom-tomorrow-night
     * Any of the doom ones really
   * Habamax Theme - a little plain
   * Also hydanatantantatna-theme
   * gruvbox
   * tsdh-light
   * tron theme https://github.com/ianpan870102/Emacs-Tron-Legacy-Theme
   * Naysayer-theme https://github.com/nickav/naysayer-theme.el
   * That one black theme i'm using right now (6/15/19)
#+end_verse

** modus themes, time on mode line
=modus-themes= is simply the GOAT at this point. Not much more to say than that.

#+begin_src emacs-lisp
(use-package modus-themes
  :straight t
  :init
  (setq modus-themes-italic-constructs t
        modus-themes-bold-constructs t
        modus-themes-mixed-fonts t
        modus-themes-no-mixed-fonts nil
        modus-themes-subtle-line-numbers t
        modus-themes-success-deuteranopia nil

        modus-themes-fringes 'subtle ; {nil,'subtle,'intense}

        ;; Options for `modus-themes-lang-checkers' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `straight-underline', `text-also', `background',
        ;; `intense'
        modus-themes-lang-checkers '(straight-underline)

        ;; Options for `modus-themes-mode-line' are either nil, or a list
        ;; that can combine any of `3d' OR `moody', `borderless',
        ;; `accented'.  The variable's doc string shows all possible
        ;; combinations.
        modus-themes-mode-line '()

        ;; Options for `modus-themes-syntax' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `faint', `yellow-comments', `green-strings', `alt-syntax'
        modus-themes-syntax '(yellow-comments green-strings alt-syntax)

        ;; Options for `modus-themes-hl-line' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `accented', `underline', `intense'
        modus-themes-hl-line '()

        ;; Options for `modus-themes-paren-match' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `bold', `intense', `underline'
        modus-themes-paren-match '(bold underline)

        ;; Options for `modus-themes-links' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `neutral-underline' OR `no-underline', `faint' OR `no-color',
        ;; `bold', `italic', `background'
        modus-themes-links '(neutral-underline background)

        ;; Options for `modus-themes-prompts' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `background', `bold', `gray', `intense', `italic'
        modus-themes-prompts '(background italic)

        modus-themes-completions 'opinionated ; {nil,'moderate,'opinionated}

        modus-themes-mail-citations nil ; {nil,'faint,'monochrome}

        ;; Options for `modus-themes-region' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `no-extend', `bg-only', `accented'
        modus-themes-region '(no-extend bg-only accented)

        ;; Options for `modus-themes-diffs': nil, 'desaturated,
        ;; 'bg-only, 'deuteranopia, 'fg-only-deuteranopia
        modus-themes-diffs 'fg-only-deuteranopia

        modus-themes-org-blocks nil ; {nil,'gray-background,'tinted-background}

        modus-themes-org-agenda ; this is an alist: read the manual or its doc string
        nil
        ;; '((header-block . (variable-pitch scale-title))
        ;;   (header-date . (grayscale workaholic bold-today))
        ;;   (scheduled . uniform)
        ;;   (habit . traffic-light-deuteranopia))

        modus-themes-headings ; this is an alist: read the manual or its doc string
        nil
        ;; '((1 . (overline background))
        ;;   (2 . (rainbow overline))
        ;;   (t . (no-bold)))

        modus-themes-variable-pitch-ui nil
        ))

(load-theme 'modus-vivendi)


#+end_src

* movement and editing
** [experimental] meow (modular editing, not evil)
- need to configure which modes this should be activated int
- some keybindings are jank
- i kinda like it

#+begin_src emacs-lisp
(use-package meow
  :disabled
  :straight (:type git :host github :repo "meow-edit/meow")
  :config
  (defun meow-setup ()
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev))
    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("j" . "H-j")
     '("k" . "H-k")
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     ;;     '("q" . meow-quit)
     ;;     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . meow-goto-line)
     '("y" . meow-save)
     '("Y" . meow-sync-grab)
     '("z" . meow-pop-selection)
     '("'" . repeat)
     '("<escape>" . mode-line-other-buffer)
     '("/" . isearch-forward)
     '("?" . isearch-backward)
     '("$" . move-end-of-line)
     '("0" . move-beginning-of-line)
     '("<" . enlarge-window-horizontally)
     '(">" . shrink-window-horizontally)
     '("}" . enlarge-window)
     '("{" . shrink-window)
     ))

  (meow-setup)

  (add-to-list 'meow-mode-state-list
               '((magit . motion)
                 (dired . motion)
                 (sly-mrepl-mode . normal)))
  ;; (setq meow-char-thing-table
  ;;       '((?\( . round)
  ;;         (?\[ . square)
  ;;         (?{ . curly)
  ;;         (?\ . string)
  ;;         (?s . symbol)
  ;;         (?w . window)
  ;;         (?b . buffer)
  ;;         (?p . paragraph)
  ;;         (?l . line)
  ;;         (?d . defun)
  ;;         (?i . indent)
  ;;         (?e . extend)))

  (meow-global-mode 1)
  )
#+end_src

** cursor positioning and duplicating
Sometimes =undo= can be unwieldy to deal with. =undo-propose= provides a scratch buffer
for that purpose. At least that's what I use it for. I understand its more powerful than
that but I'm ignorant in many ways.

=iedit= is a provides simple mark-and-multiedit capabilities. I haven't RTFM'd on
rectangle mode to see if it provides that capability, so to the externals we go.

#+begin_src emacs-lisp
(use-package undo-propose
  :straight t
  :config
  (setq undo-propose-pop-to-buffer t))

(use-package iedit
  :straight t) ;; default bind is C-;

(use-package avy
  :straight t
  :config
  (avy-setup-default)
  (define-key global-map (kbd "C-'") 'avy-goto-char-timer)
  (define-key global-map (kbd "C-\"") 'avy-resume))

(use-package expand-region
  :straight t
  :bind ("C-=" . er/expand-region))
#+end_src
** isearch and replace (getting there, clean up)
=isearch= isn't gonna go out of style anytime soon that's for sure. And especially not if
you know some of the configuration options. Below is configured for isearch to "fuzzy
search" on its candidates. This is accomplished by setting =search-whitespace-regexp= to
match =.*?=, i.e all characters are whitespace.

#+begin_src emacs-lisp
(use-package isearch
  :straight (:type built-in)
  :diminish
  :config
  (setq search-highlight t)
  (setq search-whitespace-regexp ".*?")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)
  (setq isearch-lazy-highlight t)
  ;; All of the following variables were introduced in Emacs 27.1.
  (setq isearch-lazy-count t)
  (setq lazy-count-prefix-format nil)
  (setq lazy-count-suffix-format " (%s/%s)")
  (setq isearch-yank-on-move 'shift)
  (setq isearch-allow-scroll 'unlimited)
  ;; Emacs 28
  (setq isearch-repeat-on-direction-change t)
  (setq lazy-highlight-initial-delay 0.5)
  (setq lazy-highlight-no-delay-length 3)
  (setq isearch-wrap-pause t)


  (define-key minibuffer-local-isearch-map (kbd "M-/") #'isearch-complete-edit)
  (let ((map isearch-mode-map))
    ;; (define-key map (kbd "C-g") #'isearch-cancel) ; instead of `isearch-abort'
    (define-key map (kbd "C-g") #'isearch-abort)
    (define-key map (kbd "M-/") #'isearch-complete)))

(use-package replace
  :straight (:type built-in)
  :hook ((occur-mode-hook . hl-line-mode)
         (occur-mode-hook . (lambda ()
                              (toggle-truncate-lines t))))
  :bind (("M-s M-o" . multi-occur)
         :map occur-mode-map
         ("t" . toggle-truncate-lines))
  :config
  (setq list-matching-lines-jump-to-current-line t)

  )

#+end_src

*** anzu
For a more interactive search+replace experience
#+begin_src emacs-lisp
(use-package anzu                       ; Position/matches count for isearch
  :disabled
  :straight t
  :diminish anzu-mode
  :bind
  (([remap query-replace] . anzu-query-replace)
   ([remap query-replace-regexp] . anzu-query-replace-regexp)
   :map isearch-mode-map
   ([remap isearch-query-replace] . anzu-isearch-query-replace)
   ([remap isearch-query-replace-regexp] . anzu-isearch-query-replace-regexp))
  :config
  (global-anzu-mode)
  (setq anzu-cons-mode-line-p nil)
  (set-face-attribute 'anzu-mode-line nil
                      :foreground "yellow" :weight 'bold)
  (custom-set-variables
   '(anzu-mode-lighter "")
   '(nvm-deactivate-region t)
   '(anzu-search-threshold 1000)
   '(anzu-replace-threshold 50)
   '(anzu-replace-to-string-separator " => ")))
#+end_src
** window+buffer management utilities
Without good window management, there cannot be a good editor. The imperative is to
provide a malleable, predictable, and adaptable environment built from the basics. For
this, =display-buffer= plays a key role. Perhaps more should play a larger role, but
alas.

=ibuffer= remains a time-tested classic. It does exactly its job: logical grouping of
buffers with some enhanced information over =list-buffers=.

I have a love-hate relationship with =desktop=. I haven't read the manual enough to
find the right configuration required to have a more seamless start-up and shut-down. But
it remains.

=tab-bar= is an interesting addition to the Emacs built-ins. I'd guess the experience
should emulate a typical tab system in, say, VS-Code. But I don't have much experience
with this package so I have nothing intelligent to say about it yet.

Currently =popper= is lightly used in dealing with evanescent buffers.

#+begin_src emacs-lisp
;; inputmono is my current font kick. DejaVu won't go out of style though.
(set-frame-font "Deja Vu Sans Mono 12")
(define-key global-map (kbd "M-o") 'other-window)
(define-key global-map (kbd "M-O") (lambda () (interactive) (other-window -1)))

(use-package ibuffer                    ; Better buffer list
  :straight (:type built-in)
  :bind (([remap list-buffers] . ibuffer))
  :config
  ;; as always, from prot:
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 40 40 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook #'hl-line-mode)
  (define-key global-map (kbd "C-x C-b") #'ibuffer)
  (let ((map ibuffer-mode-map))
    (define-key map (kbd "* f") #'ibuffer-mark-by-file-name-regexp)
    (define-key map (kbd "* g") #'ibuffer-mark-by-content-regexp) ; "g" is for "grep"
    (define-key map (kbd "* n") #'ibuffer-mark-by-name-regexp)
    (define-key map (kbd "s n") #'ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
    (define-key map (kbd "/ g") #'ibuffer-filter-by-content))
  )

(use-package desktop
  :disabled
  :straight (:type built-in)
  :config
  (setq desktop-auto-save-timeout 300)
  (setq desktop-path '("~/.emacs.d/"))
  (setq desktop-base-file-name "desktop")
  (setq desktop-files-not-to-save ".*magit.*")
  (setq desktop-modes-not-to-save '(magit-mode magit-status-mode help-mode info-mode
                                               compilation-mode-map tags-table-mode completion-mode))
  (setq desktop-load-locked-desktop t)
  (setq desktop-missing-file-warning t)
  (setq desktop-restore-eager 10)
  (setq desktop-restore-frames t)
  (setq desktop-save 'ask-if-new)
  (desktop-save-mode 1))

(use-package tab-bar
  :straight (:type built-in)
  :init
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)

  (setq tab-nav-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "b") 'switch-to-buffer-other-tab)
          (define-key map (kbd "d") 'dired-other-tab)
          (define-key map (kbd "f") 'find-file-other-tab)
          (define-key map (kbd "n") 'tab-next)
          (define-key map (kbd "p") 'tab-previous)
          (define-key map (kbd "0") 'tab-close)
          (define-key map (kbd "1") 'tab-close-other)
          (define-key map (kbd "2") 'tab-bar-new-tab)
          (define-key map (kbd "l") 'tab-list)
          map))
  (define-key global-map (kbd "C-c C-t") tab-nav-map)
  :config
  (tab-bar-mode -1)
  (tab-bar-history-mode -1)
  :bind (("<prior>" . tab-next)
         ("<next>" . tab-previous)))

;; Thank you prot (see
;; https://protesilaos.com/dotemacs/#h:c110e399-3f43-4555-8427-b1afe44c0779)
(use-package window
  :straight (:type built-in)
  :init
  (define-key global-map (kbd "C-x C-o") 'display-buffer)
  ;; [2021-12-21 Tue] C-x C-{p,n} go to next/previous buffer (new to me)
  (setq display-buffer-alist
        `(
          ;; below current window
          ("\\*\\(e?shell\\|v?term\\|.*geiser.*\\|\\)\\*"
           (display-buffer-below-selected)
           (window-height . 0.3))
          ("\\*Org Agenda\\*"
           (display-buffer-reuse-window display-buffer-same-window))
          (".*eww.*"
           (display-buffer-reuse-window display-buffer-same-window))
          ("\\*Org Src.*"
           (display-buffer-reuse-window display-buffer-same-window)
           (window-height . fit-window-to-buffer))
          ("\\`\\*Async Shell Command\\*\\'"
           (display-buffer-no-window))
          ;; top side window
          ("\\*\\(Flymake diagnostics\\|Package-Lint\\|flycheck\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Flymake log\\|compilation\\|\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2))
          ;; left side window
          ("\\*\\(.* # Help.*\\|Help\\)\\*" ; See the hooks for `visual-line-mode'
           (display-buffer-reuse-mode-window display-buffer-in-side-window)
           (window-width . 0.25)
           (side . left)
           (slot . 0))
          ;; bottom buffer (NOT side window)
          ("\\*Embark Actions\\*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . fit-window-to-buffer)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ("\\*\\(Embark\\)?.*Completions.*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-parameters . ((no-other-window . t))))
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom))

          ("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           ;; NOTE 2021-10-06: we cannot `fit-window-to-buffer' because
           ;; the height is not known in advance.
           (window-height . 0.4))
          ("magit: .*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . 0.4))
          ("\\*\\(Calendar\\|Bookmark Annotation\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . fit-window-to-buffer))))

  (defvar resize-window-repeat-map
    (let ((map (make-sparse-keymap)))
      ;; Standard keys:
      (define-key map "^" 'enlarge-window)
      (define-key map "}" 'enlarge-window-horizontally)
      (define-key map "{" 'shrink-window-horizontally) ; prot note: those three are C-x KEY
      ;; Additional keys:
      (define-key map "v" 'shrink-window) ; prot note: this is not bound by default
      map)
    "Keymap to repeat window resizing commands.  Used in `repeat-mode'.")
  (put 'enlarge-window 'repeat-map 'resize-window-repeat-map)
  (put 'enlarge-window-horizontally 'repeat-map 'resize-window-repeat-map)
  (put 'shrink-window-horizontally 'repeat-map 'resize-window-repeat-map)
  (put 'shrink-window 'repeat-map 'resize-window-repeat-map)

  (let ((map global-map))
    (define-key map (kbd "C-x <down>") #'next-buffer)
    (define-key map (kbd "C-x <up>") #'previous-buffer)
    (define-key map (kbd "C-x C-n") #'next-buffer)     ; override `set-goal-column'
    (define-key map (kbd "C-x C-p") #'previous-buffer) ; override `mark-page'
    (define-key map (kbd "C-x !") #'delete-other-windows-vertically)
    (define-key map (kbd "C-x _") #'balance-windows)      ; underscore
    (define-key map (kbd "C-x -") #'fit-window-to-buffer) ; hyphen
    (define-key map (kbd "C-x +") #'balance-windows-area)
    (define-key map (kbd "C-x }") #'enlarge-window)
    (define-key map (kbd "C-x {") #'shrink-window)
    (define-key map (kbd "C-x >") #'enlarge-window-horizontally) ; override `scroll-right'
    (define-key map (kbd "C-x <") #'shrink-window-horizontally)) ; override `scroll-left'
  :hook ((help-mode-hook . visual-line-mode)
         (custom-mode-hook . visual-line-mode)))

(use-package winner
  :config
  (winner-mode t)     ; move between windows configuration
  )

;;; Directional window motions (windmove)
(use-package popper
  :straight t
  :bind (("C-M-q"   . (lambda ()
                        (interactive)
                        (popper-toggle-latest)
                        (other-window 1)))
         ("M-`"   . popper-cycle)
         ("C-M-`" . popper-toggle-type))
  :init
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          "magit: .*"
          eshell-mode
          shell-mode
          help-mode
          geiser-repl-mode
          magit-mode
          compilation-mode))
  (setq popper-display-control nil) ;; let display-buffer handle it    
  (popper-mode +1)
  (popper-echo-mode +1))
#+end_src
** outlines and outline mode
#+begin_src emacs-lisp
(use-package outline
  :straight (:type built-in)
  :diminish outline-minor-mode
  :hook
  (prog-mode . outline-minor-mode)
  (markdown-mode . outline-minor-mode)
  (conf-mode . outline-minor-mode)
  (LaTeX-mode . outline-minor-mode)
  :config
  (setq outline-minor-mode-cycle t
        outline-minor-mode-highlight 'append))
#+end_src
** really long lines
#+begin_src emacs-lisp
(use-package so-long
  :straight (:type built-in)
  :diminish
  :config
  (global-so-long-mode 1))
#+end_src
* reading, writing, and tasks
** org
#+begin_src emacs-lisp
(use-package org
  ;; TODO: fix this with the right straight source
  :straight t
  :config
  ;; (unbind-key (kbd "C-'") org-mode-map)
  ;; (unbind-key (kbd "C-c C-j") org-mode-map)
  (defun org-file-path (filename)
    "Return absolute address of an org file give its relative name."
    (concat (file-name-as-directory org-directory) filename))

;;; org latex interplay
  (setq-default org-highlight-latex-and-related '(native latex script entities))
  (setq org-latex-listings 'minted) ;; export source code with color+font
  (setq org-startup-folded t)
  (setq org-pretty-entities t)
  (setq org-pretty-entities-include-sub-superscripts nil) ; not a fan of hidden characters
  (setq org-indirect-buffer-display #'current-window)

;;; babel
  ;; NOTE: If this isn't working, make sure to delete /
  ;; byte-recompile the /elpa/org/.. directory.
  ;; enable language compiles
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (gnuplot . t)))

  (setq org-src-window-setup 'plain) ;; let display-buffer handle it
  (setq org-confirm-babel-evaluate nil)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-edit-src-content-indentation 0)

;;; general org configuration. Lots of inspiration and discovery from Prot's org configuration (glad he RTFM!)
  (setq org-directory "~/org/")
  (setq org-inbox-directory org-directory)
  (setq org-imenu-depth 7)
  (setq org-special-ctrl-a/e nil)
  (setq org-special-ctrl-k nil)
  (setq org-hide-emphasis-markers nil)
  (setq org-M-RET-may-split-line '((default . nil)))
  (setq org-hide-leading-stars nil)
  (setq org-cycle-separator-lines 0)
  (setq org-structure-template-alist
        '(("s" . "src")
          ("E" . "src emacs-lisp")
          ("e" . "example")
          ("q" . "quote")
          ("v" . "verse")
          ("V" . "verbatim")
          ("c" . "center")
          ("C" . "comment")))
  (setq org-catch-invisible-edits 'show)
  (setq org-return-follows-link nil)
  (setq org-loop-over-headlines-in-active-region 'start-level)
  (setq org-use-sub-superscripts '{})   ; not a big fan of the ambiguity
  (setq org-insert-heading-respect-content t)


  ;; tags
  (setq org-tags-match-list-sublevels t)

  ;; refile
  (setq org-refile-targets '((all-org-files :maxlevel . 3)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps t)
  (setq org-refile-allow-creating-parent-nodes 'confirm) ; allow creating new parents on refile
  (setq org-refile-use-cache t)

  ;; todos
  (setq org-reverse-note-order nil)
  (setq org-todo-keywords
        '((sequence "TODO(t)" "MAYBE(m)" "WAIT(w@/!)" "|" "CANCEL(c@)" "DONE(d!)")))
  (setq org-todo-keyword-faces
        '(("WAIT" . '(bold org-todo))
          ("MAYBE" . '(bold shadow))
          ("CANCEL" . '(bold org-done))))
  (setq org-use-fast-todo-selection 'expert)
  (setq org-priority-faces
        '((?A . '(bold org-priority))
          (?B . org-priority)
          (?C . '(shadow org-priority))))
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-heading-line nil)
  (setq org-fontify-whole-block-delimiter-line nil)
  (setq org-highlight-latex-and-related nil) ; other options affect elisp regexp in src blocks
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?A)

;;; logging
  (setq org-log-done 'time)             ; also record when the TODO was archived
  (setq org-log-into-drawer t)
  (setq org-log-note-clock-out nil)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-read-date-prefer-future 'time)

;;; links
  (setq org-link-keep-stored-after-insertion nil)

;;; agenda
;;;;; Basic agenda setup
  (setq org-default-notes-file (thread-last org-directory (expand-file-name "notes.org")))
  (setq org-agenda-files `(,org-directory "~/org/roam/"))
  (setq org-agenda-span 'week)
  (setq org-agenda-start-on-weekday 1)  ; Monday
  (setq org-agenda-confirm-kill t)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-show-outline-path nil)
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-skip-comment-trees t)
  (setq org-agenda-menu-show-matcher t)
  (setq org-agenda-menu-two-columns nil)
  (setq org-agenda-sticky nil)
  (setq org-agenda-custom-commands-contexts nil)
  (setq org-agenda-max-entries nil)
  (setq org-agenda-max-todos nil)
  (setq org-agenda-max-tags nil)
  (setq org-agenda-max-effort nil)

  (run-at-time (* 60 5) nil #'org-agenda-to-appt)

  (setq org-agenda-files (list (org-file-path "tasks.org")))
  (define-key global-map (kbd "C-c a") 'org-agenda)

  ;; Place tags close to the right-hand side of the window
  (defun place-agenda-tags ()
    "Put the agenda tags by the right border of the agenda window."
    (setq org-agenda-tags-column 110)
    (org-agenda-align-tags))
  (add-hook 'org-finalize-agenda-hook 'place-agenda-tags)

  (setq org-agenda-compact-blocks t)
  (setq org-agenda-block-separator 45)
  (setq org-agenda-sorting-strategy
        '(((agenda habit-down time-up priority-down category-keep)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
  (setq org-agenda-breadcrumbs-separator "->")
  (setq org-agenda-fontify-priorities 'cookies)
  (setq org-agenda-category-icon-alist nil)
  (setq org-agenda-remove-times-when-in-prefix nil)
  (setq org-agenda-remove-timeranges-from-blocks nil)
  (setq org-agenda-compact-blocks nil)
  (setq org-agenda-block-separator ?â€”)

;;;;; Agenda marks
  (setq org-agenda-bulk-mark-char ">")
  (setq org-agenda-persistent-marks nil)

;;;;; Agenda diary entries
  (setq org-agenda-insert-diary-strategy 'date-tree)
  (setq org-agenda-insert-diary-extract-time nil)
  (setq org-agenda-include-diary t) ;; TODO: i'm not so sure about this yet

;;;;; Agenda follow mode
  (setq org-agenda-start-with-follow-mode nil)
  (setq org-agenda-follow-indirect t)

;;;;; Agenda multi-item tasks
  (setq org-agenda-dim-blocked-tasks t)
  (setq org-agenda-todo-list-sublevels t)

;;;;; Agenda filters and restricted views
  (setq org-agenda-persistent-filter nil)
  (setq org-agenda-restriction-lock-highlight-subtree t)

;;;;; Agenda items with deadline and scheduled timestamps
  (setq org-agenda-include-deadlines t)
  (setq org-deadline-warning-days 5)
  (setq org-agenda-skip-scheduled-if-done nil)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
  (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
  (setq org-agenda-skip-deadline-if-done nil)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 1)
  (setq org-agenda-skip-scheduled-delay-if-deadline nil)
  (setq org-agenda-skip-additional-timestamps-same-entry nil)
  (setq org-agenda-skip-timestamp-if-done nil)
  (setq org-agenda-search-headline-for-time nil)
  (setq org-scheduled-past-days 365)
  (setq org-deadline-past-days 365)
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-show-future-repeats t)
  (setq org-agenda-prefer-last-repeat nil)
  (setq org-agenda-timerange-leaders
        '("" "(%d/%d): "))
  (setq org-agenda-scheduled-leaders
        '("Scheduled: " "Sched.%2dx: "))
  (setq org-agenda-inactive-leader "[")
  (setq org-agenda-deadline-leaders
        '("Deadline:  " "In %3d d.: " "%2d d. ago: "))
  ;; Time grid
  (setq org-agenda-time-leading-zero t)
  (setq org-agenda-timegrid-use-ampm nil)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-show-current-time-in-grid t)
  (setq org-agenda-current-time-string
        (concat "Now " (make-string 70 ?-)))
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (0600 0700 0800 0900 1000 1100
                1200 1300 1400 1500 1600
                1700 1800 1900 2000 2100)
          " ....." "-----------------"))
  (setq org-agenda-default-appointment-duration nil)

;;;;; Agenda global to-do list
  (setq org-agenda-todo-ignore-with-date t)
  (setq org-agenda-todo-ignore-timestamp t)
  (setq org-agenda-todo-ignore-scheduled t)
  (setq org-agenda-todo-ignore-deadlines t)
  (setq org-agenda-todo-ignore-time-comparison-use-seconds t)
  (setq org-agenda-tags-todo-honor-ignore-options nil)

;;;;; Agenda tagged items
  (setq org-agenda-show-inherited-tags t)
  (setq org-agenda-use-tag-inheritance
        '(todo search agenda))
  (setq org-agenda-hide-tags-regexp nil)
  (setq org-agenda-remove-tags nil)
  (setq org-agenda-tags-column -100)

;;;;; Agenda entry
  ;; NOTE: I do not use this right now.  Leaving everything to its
  ;; default value.
  (setq org-agenda-start-with-entry-text-mode nil)
  (setq org-agenda-entry-text-maxlines 5)
  (setq org-agenda-entry-text-exclude-regexps nil)
  (setq org-agenda-entry-text-leaders "    > ")

;;;;; Agenda logging and clocking
  ;; NOTE: I do not use these yet, though I plan to.  Leaving everything
  ;; to its default value for the time being.
  (setq org-agenda-log-mode-items '(closed clock))
  (setq org-agenda-clock-consistency-checks
        '((:max-duration "10:00" :min-duration 0 :max-gap "0:05" :gap-ok-around
                         ("4:00")
                         :default-face  ; This should definitely be reviewed
                         ((:background "DarkRed")
                          (:foreground "white"))
                         :overlap-face nil :gap-face nil :no-end-time-face nil
                         :long-face nil :short-face nil)))
  (setq org-agenda-log-mode-add-notes t)
  (setq org-agenda-start-with-log-mode nil)
  (setq org-agenda-start-with-clockreport-mode nil)
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2))
  (setq org-agenda-search-view-always-boolean nil)
  (setq org-agenda-search-view-force-full-words nil)
  (setq org-agenda-search-view-max-outline-level 0)
  (setq org-agenda-search-headline-for-time t)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-cmp-user-defined nil)
  (setq org-agenda-sort-notime-is-late t)   ; Org 9.4
  (setq org-agenda-sort-noeffort-is-high t) ; Org 9.4

;;;;; Agenda column view
  ;; NOTE I do not use these, but may need them in the future.
  (setq org-agenda-view-columns-initially nil)
  (setq org-agenda-columns-show-summaries t)
  (setq org-agenda-columns-compute-summary-properties t)
  (setq org-agenda-columns-add-appointments-to-effort-sum nil)
  (setq org-agenda-auto-exclude-function nil)
  (setq org-agenda-bulk-custom-functions nil)

  (setq org-agenda-custom-commands
        `(("a" "What's Going On"
           ,`((tags-todo "*"
                         ((org-agenda-skip-function '(org-agenda-skip-if nil '(timestamp)))
                          (org-agenda-skip-function
                           `(org-agenda-skip-entry-if
                             'notregexp ,(format "\\[#%s\\]" (char-to-string org-priority-highest))))
                          (org-agenda-block-separator nil)
                          (org-agenda-overriding-header "Important tasks without a date\n")))
              (agenda "" ((org-agenda-time-grid nil)
                          (org-agenda-start-on-weekday nil)
                          (org-agenda-span 1)
                          (org-agenda-show-all-dates nil)
                          (org-scheduled-past-days 365)
                          ;; Excludes today's scheduled items
                          (org-scheduled-delay-days 1)
                          (org-agenda-block-separator nil)
                          (org-agenda-entry-types '(:scheduled))
                          (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                          (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                          (org-agenda-format-date "")
                          (org-agenda-overriding-header "\nPending scheduled tasks")))
              (agenda "" ((org-agenda-span 1)
                          (org-deadline-warning-days 0)
                          (org-agenda-block-separator nil)
                          (org-scheduled-past-days 0)
                          ;; We don't need the `org-agenda-date-today'
                          ;; highlight because that only has a practical
                          ;; utility in multi-day views.
                          (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                          (org-agenda-format-date "%A %-e %B %Y")
                          (org-agenda-overriding-header "\nToday's agenda\n")))
              (agenda "" ((org-agenda-start-on-weekday nil)
                          (org-agenda-start-day "+1d")
                          (org-agenda-span 3)
                          (org-deadline-warning-days 0)
                          (org-agenda-block-separator nil)
                          (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                          (org-agenda-overriding-header "\nNext three days\n")))
              (agenda "" ((org-agenda-time-grid nil)
                          (org-agenda-start-on-weekday nil)
                          ;; We don't want to replicate the previous section's
                          ;; three days, so we start counting from the day after.
                          (org-agenda-start-day "+4d")
                          (org-agenda-span 14)
                          (org-agenda-show-all-dates nil)
                          (org-deadline-warning-days 0)
                          (org-agenda-block-separator nil)
                          (org-agenda-entry-types '(:deadline))
                          (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                          (org-agenda-overriding-header "\nUpcoming deadlines (+14d)\n"))))
           )))

  ;; Bind C-c C-x C-s to mark todo as done and archive it
  (defun lp/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it"
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'lp/mark-done-and-archive)

;;; capturing
  (define-key global-map (kbd "C-c c") 'org-capture)
  (setq org-capture-templates
        `(("b" "Basic task for future review" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* %^{Title}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%l")
           :empty-lines-after 1)
          ("m" "Memorandum of conversation" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* Memorandum of conversation with %^{Person}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%?")
           :empty-lines-after 1)
          ("t" "Task with a due date" entry
           (file+headline "tasks.org" "Tasks with a date")
           ,(concat "* TODO %^{Title} %^g\n"
                    "SCHEDULED: %^t\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%?")
           :empty-lines-after 1)
          ("e" "Email note" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* MAYBE %:subject :mail:\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%a\n%i%?")
           :empty-lines-after 1)))

  (setq org-capture-templates-contexts
        '(("e" ((in-mode . "notmuch-search-mode")
                (in-mode . "notmuch-show-mode")
                (in-mode . "notmuch-tree-mode")))))

;;; autofill
  ;; Auto wrap paragraphs in some modes (auto-fill-mode)
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
  (define-key org-mode-map (kbd "C-c q") 'auto-fill-mode)

;;; making links to other contexts
  (define-key global-map (kbd "C-c l") 'org-store-link)

  )

(use-package org-roam
  :straight (:type git :host github
                   :repo "org-roam/org-roam-v1" :branch "master")
  :diminish
  :custom
  (org-roam-directory (file-truename "~/org/roam/"))
  (org-roam-graph-exclude-matcher '("physics" "textbook" "quote" "paper" "private" "daily" "index" "Index"))
  (org-roam-dailies-directory "daily/")
  (org-roam-db-update-idle-seconds 20)
  :init
  (add-hook 'after-init-hook 'org-roam-mode)
  :config
  (define-key org-roam-dailies-map (kbd "l") 'org-roam-dailies-find-today)
  (define-key org-roam-dailies-map (kbd "j") 'org-roam-dailies-find-tomorrow)
  (define-key org-roam-dailies-map (kbd "d") 'org-roam-dailies-find-date)
  (define-key org-roam-dailies-map (kbd "k") 'org-roam-dailies-find-yesterday)
  (define-key org-roam-dailies-map (kbd "p") 'org-roam-dailies-find-previous-note)
  (define-key org-roam-dailies-map (kbd "n") 'org-roam-dailies-find-next-note)

  (setq roam-nav-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "f") 'org-roam-find-file)
          (define-key map (kbd "c") 'org-roam-capture)
          (define-key map (kbd "i") 'org-roam-insert)
          (define-key map (kbd "r") 'org-roam)
          (define-key map (kbd "I") 'org-roam-insert-immediate)
          (define-key map (kbd "g") 'org-roam-graph)
          (define-key map (kbd "o") 'org-roam-jump-to-index)
          (define-key map (kbd "t") 'org-roam-tag-add)
          map))
  (define-key global-map (kbd "C-c C-u") roam-nav-map)

  (eval-after-load "cape"
    (progn
      (add-to-list 'org-roam-completion-functions #'cape-file)
      (add-to-list 'org-roam-completion-functions #'cape-dabbrev)
      (add-to-list 'org-roam-completion-functions #'cape-keyword)
      (add-to-list 'org-roam-completion-functions #'cape-abbrev)
      (add-to-list 'org-roam-completion-functions #'cape-ispell)
      (add-to-list 'org-roam-completion-functions #'cape-dict)
      (add-to-list 'org-roam-completion-functions #'cape-symbol)))
  :bind (("\C-c i" . org-roam-insert-immediate)
         ("\C-c o" . org-roam-jump-to-index)
         ("\C-c t" . org-roam-tag-add)
         ("\C-c f" . org-roam-find-file)
         ("\C-c d" . org-roam-dailies-map)))

(use-package org-roam-server
  :straight t
  :config
  (setq org-roam-server-host "localhost"
        org-roam-server-port 8080
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files nil
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20))
#+end_src

** diary, calendar
#+begin_src emacs-lisp
(use-package calendar
  :straight (:type built-in)
  :config
  ;; lots ripped from prot
  (setq calendar-mark-diary-entries-flag t)
  (setq calendar-mark-holidays-flag t)
  (setq calendar-mode-line-format nil)
  (setq calendar-time-display-form
        '(24-hours ":" minutes
                   (when time-zone
                     (format "(%s)" time-zone))))
  (setq calendar-week-start-day 1)      ; Monday
  (setq calendar-date-style 'iso)
  (setq calendar-date-display-form calendar-iso-date-display-form)
  (setq calendar-time-zone-style 'numeric) ; Emacs 28.1

  (require 'solar)
  (setq calendar-latitude 39.0         ; Not my actual coordinates
        calendar-longitude -76.4)

  (require 'cal-dst)
  (setq calendar-standard-time-zone-name "EST")
  (setq calendar-daylight-time-zone-name "EDT")

  (require 'diary-lib)
  (setq diary-file (file-truename "~/org/diary"))
  (setq user-mail-address "liampacker@gmail.com")
  (setq diary-mail-addr user-mail-address)
  (setq diary-date-forms diary-iso-date-forms)
  (setq diary-comment-start ";;")
  (setq diary-comment-end "")
  (setq diary-nonmarking-symbol "!")
  (setq diary-show-holidays-flag t)
  (setq diary-display-function #'diary-fancy-display) ; better than its alternative
  (setq diary-header-line-format nil)
  (setq diary-list-include-blanks nil)
  (setq diary-number-of-entries 2)
  (setq diary-mail-days 2)
  (setq diary-abbreviated-year-flag nil)

  (add-hook 'calendar-today-visible-hook #'calendar-mark-today)
  (add-hook 'diary-list-entries-hook 'diary-sort-entries t)
  (add-hook 'diary-mode-hook #'goto-address-mode) ; buttonise plain text links

  ;; Those presuppose (setq diary-display-function #'diary-fancy-display)
  (add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
  (add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)

  ;; Prevent Org from interfering with my key bindings.
  (remove-hook 'calendar-mode-hook #'org--setup-calendar-bindings)

  (let ((map calendar-mode-map))
    (define-key map (kbd "s") #'calendar-sunrise-sunset)
    (define-key map (kbd "l") #'lunar-phases)
    (define-key map (kbd "i") nil) ; Org sets this, much to my chagrin (see `remove-hook' above)
    (define-key map (kbd "i a") #'diary-insert-anniversary-entry)
    (define-key map (kbd "i b") #'diary-insert-block-entry)
    (define-key map (kbd "i c") #'diary-insert-cyclic-entry)
    (define-key map (kbd "i d") #'diary-insert-entry) ; for current "day"
    (define-key map (kbd "i i") #'diary-insert-entry) ; most common action, easier to type
    (define-key map (kbd "i m") #'diary-insert-monthly-entry)
    (define-key map (kbd "i w") #'diary-insert-weekly-entry)
    (define-key map (kbd "i y") #'diary-insert-yearly-entry)
    (define-key map (kbd "M-n") #'calendar-forward-month)
    (define-key map (kbd "M-p") #'calendar-backward-month)))

(use-package appt
  :straight (:type built-in)
  :config
  (setq appt-display-diary nil)
  (setq appt-disp-window-function #'appt-disp-window)
  (setq appt-display-mode-line t)
  (setq appt-display-interval 3)
  (setq appt-audible nil)
  (setq appt-warning-time-regexp "appt \\([0-9]+\\)")
  (setq appt-message-warning-time 6)

  (run-at-time 10 nil #'appt-activate 1))

;;; modified from prot. while its a great idea, it can be problematic to automatically email from different computers
;; The idea is to get a reminder via email when I launch Emacs in the
;; morning and this file is evaluated.  Obviously this is not a super
;; sophisticated approach, though I do not need one.
;; (let ((time (string-to-number (format-time-string "%H"))))
;;   (when (and (> time 4) (< time 9))
;;     (run-at-time (* 60 5) nil #'diary-mail-entries)))

(require 'holidays)

;; This weirdly needs to come after =org-roam=. otherwise these binds are shadowed by the
;; =org-roam-dailies-map= assignment
(let ((map global-map))
  (define-key map (kbd "C-c d c") #'calendar)
  ;; (define-key map (kbd "C-c d d") #'prot-diary-display-entries)
  ;; (define-key map (kbd "C-c d e") #'prot-diary-edit-diary)
  (define-key map (kbd "C-c d i") #'diary-insert-entry)
  (define-key map (kbd "C-c d m") #'diary-mail-entries))
#+end_src

** latex
#+begin_src emacs-lisp
(use-package org-ref
  :straight t
  :config

  (use-package async
    :straight t)

  (require 'async)
  (require 'org-ref-bibtex)
  (require 'doi-utils)
  (require 'org-ref-arxiv)

  (setq bibtex-autokey-year-length 4
        bibtex-autokey-name-year-separator "-"
        bibtex-autokey-year-title-separator "-"
        bibtex-autokey-titleword-separator "-"
        bibtex-autokey-titlewords 2
        bibtex-autokey-titlewords-stretch 1
        bibtex-autokey-titleword-length 5
        org-ref-bibtex-hydra-key-binding (kbd "C-c C-]"))
  (define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)
  (setq bibtex-completion-bibliography '("~/org/bib/index.bib"
                                         "~/org/bib/archive.bib")
        org-ref-default-bibliography '("~/org/bib/index.bib")
        org-ref-pdf-directory "~/org/bib/lib/")

  (setq
   bibtex-completion-library-path '("~/org/bib/bibtex-pdfs/")
   bibtex-completion-notes-path "~/org/roam/"))


(use-package tex-mode
  :config
  ;; revert pdf-view after compilation
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-source-correlate-start-server t
        TeX-source-correlate-mode t
        TeX-source-correlate-method 'synctex)

  (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
  (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-buffer)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  )
#+end_src
** markdown
#+begin_src emacs-lisp
(use-package markdown-mode
  :straight t
  :defer t
  :diminish (markdown-mode gfm-mode)
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+end_src
** pdf-tools
#+begin_src emacs-lisp
(use-package pdf-tools
  :straight t
  :config
  (setq pdf-tools-enabled-modes
        '(pdf-history-minor-mode
          pdf-isearch-minor-mode
          pdf-links-minor-mode
          pdf-outline-minor-mode
          pdf-misc-size-indication-minor-mode
          pdf-occur-global-minor-mode))

  (setq pdf-view-display-size 'fit-width)
  (setq pdf-view-continuous t)
  (setq pdf-view-use-dedicated-register nil)
  (setq pdf-view-max-image-width 1080)
  (setq pdf-outline-imenu-use-flat-menus t)

  (pdf-loader-install)

  ;;; credits to prot as always!
  ;; Those functions and hooks are adapted from the manual of my modus-themes.
  ;; The idea is to (i) add a backdrop that is distinct from the background of
  ;; the PDF's page and (ii) make pdf-tools adapt to theme switching via, e.g.,
  ;; `modus-themes-toggle'.
  (defun prot/pdf-tools-backdrop ()
    (face-remap-add-relative
     'default `(:background
                ,(modus-themes-color
                  'bg-alt))))

  (defun prot/pdf-tools-midnight-mode-toggle ()
    (when (derived-mode-p 'pdf-view-mode)
      (if (eq (car custom-enabled-themes) 'modus-vivendi)
          (pdf-view-midnight-minor-mode 1)
        (pdf-view-midnight-minor-mode -1))
      (prot/pdf-tools-backdrop)))

  (add-hook 'pdf-tools-enabled-hook #'prot/pdf-tools-midnight-mode-toggle)
  (add-hook 'modus-themes-after-load-theme-hook #'prot/pdf-tools-midnight-mode-toggle))
#+end_src

** ispell+flyspell
=ispell= and =flyspell= are built-in utilities to interface with externally installed
spelling programs (=hunspell=, =aspell=, =ispell=, etc.). =flyspell= is much like
=flymake= where, on the fly, misspelled words are highlighted as you type them or move
over them. Words not passed or typed will not be checked unless explicitly invoked by
=flyspell-buffer=. =ispell= provides functionality for checking and correcting spelling
on-command.

=ispell= provides some fairly sophisticated, but simple, capabilities when correcting a
word. After invoking =ispell= (=M-$=), a buffer pops up which details what corrections are
known by the external spelling program for the word at point. A user can choose a
correction (digit), skip (=<SPC>=), replace word-at-point with a new word (=r NEW <RET>=),
replace all occurrences of the word at point (=R NEW <RET>=), accept the incorrect word
(=a=), insert this word into a private dictionary file (=i=, =m=), and a couple of other
actions specified in the manual.

#+begin_src emacs-lisp
(use-package ispell
  :straight (:type built-in)
  :init
  (setq ispell-dictionary "en_US")
  (setq ispell-silently-savep t))

(use-package flyspell
  :straight (:type built-in)
  :diminish flyspell-mode
  :hook ((org-mode-hook markdown-mode-hook) . (lambda () (interactive) (flyspell-mode)))
  :config
  (setq flyspell-issue-message-flag nil)
  (setq flyspell-issue-welcome-flag nil)
  (define-key flyspell-mode-map (kbd "C-;") nil) ;; gets in the way of things.
  )
#+end_src

* minibuffer, completion, and definitions
** mct, minimalist completion
[2021-12-06] I gave it a serious try but MCT isn't gonna cut it. I'd like my
completions to be done quicker.

#+begin_src emacs-lisp
(use-package mct
  :straight t
  :config
  (setq mct-remove-shadowed-file-names t) ; works when `file-name-shadow-mode' is enabled
  (setq mct-hide-completion-mode-line t)
  (setq mct-show-completion-line-numbers nil)
  (setq mct-apply-completion-stripes t)
  (setq mct-minimum-input 4)
  (setq mct-live-update-delay 0.6)
  (setq mct-completions-format 'one-column)

  ;; NOTE: `mct-completion-blocklist' can be used for commands with lots
  ;; of candidates, depending also on how low `mct-minimum-input' is.
  ;; With the settings shown here this is not required, otherwise I would
  ;; use something like this:
  ;;
  (setq mct-completion-blocklist
        '( describe-symbol describe-function describe-variable
           execute-extended-command insert-char))

  ;; This is for commands that should always pop up the completions'
  ;; buffer.  It circumvents the default method of waiting for some user
  ;; input (see `mct-minimum-input') before displaying and updating the
  ;; completions' buffer.
  (setq mct-completion-passlist
        '(imenu
          Info-goto-node
          Info-index
          Info-menu
          vc-retrieve-tag))

  ;; You can place the Completions' buffer wherever you want, by following
  ;; the syntax of `display-buffer'.  For example, try this:

  ;; (setq mct-display-buffer-action
  ;;       (quote ((display-buffer-reuse-window
  ;;                display-buffer-in-side-window)
  ;;               (side . left)
  ;;               (slot . 99)
  ;;               (window-width . 0.3))))

  (mct-mode 1)
  ;; (define-key vertico-map (kbd "M-RET") #'minibuffer-force-complete-and-exit)
  ;; (define-key vertico-map (kbd "M-TAB") #'minibuffer-complete)
  )
#+end_src

** general minibuffer completion configuration
completion options, minibuffer options, minibuffer history options, prompt faces, ...
#+begin_src emacs-lisp
(setq completion-show-inline-help t)
(setq completions-detailed t)
(setq completion-ignore-case t)

(setq completion-cycle-threshold 3) ;; always allow tab cycle
;; emacs28 completion stuff
(setq completions-group t)
(setq completions-group-sort nil)


(setq enable-recursive-minibuffers t)
(setq minibuffer-eldef-shorten-default t) ;; default completion in [bracks]

(setq read-buffer-completion-ignore-case t)
(setq read-file-name-completion-ignore-case t)

(setq resize-mini-windows t)

(file-name-shadow-mode 1)
(minibuffer-depth-indicate-mode 1)
(minibuffer-electric-default-mode 1) ;; update default completion if change

     ;;; Minibuffer history
(use-package savehist
  :straight (:type built-in)
  :config
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 10000)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (add-hook 'after-init-hook #'savehist-mode))

;; Add prompt indicator to `completing-read-multiple'.
;; Alternatively try `consult-completing-read-multiple'.
(defun crm-indicator (args)
  (cons (concat "[CRM] " (car args)) (cdr args)))
(advice-add #'completing-read-multiple :filter-args #'crm-indicator)

;; Do not allow the cursor in the minibuffer prompt
(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))
#+end_src

** consult
consult is an important set of utilities that extend a number of important built-in
functions (like =list-buffers=, =goto-line=), where comprehensive completions and
additional utilities are provided within-command.

I set up a number of consult maps for quick access to important commands. Notable maps are
the =consult-goto-map= containing any "jumping" commands such as =imenu=, =outline=, and
so forth, and the =consult-search-map= containing any "searching" commands such as
=ripgrep=, =isearch=, and so forth.

Importantly: =consult= is can be used for word completion in terminal mode when a visual
posframe-based or frame-based completion utility, e.g. =corfu= can't be displayed. It
doesn't play well with lsp, but i haven't heard anything about =eglot=.

#+begin_src emacs-lisp
(use-package consult
  :straight t
  :bind
  (("C-x b" . consult-buffer)
   ("C-M-y" . consult-yank-pop)
   ("C-:" . consult-complex-command)
   ([remap apropos-command] . consult-apropos))
  :init
  (setq consult-goto-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "e") 'consult-compile-error)
          (define-key map (kbd "l") 'consult-flymake)
          (define-key map (kbd "f") 'consult-flycheck)               ;; Alternative: consult-flycheck
          (define-key map (kbd "g") 'consult-goto-line)             ;; orig. goto-line
          (define-key map (kbd "o") 'consult-outline)               ;; Alternative: consult-org-heading
          (define-key map (kbd "m") 'consult-mark)
          (define-key map (kbd "k") 'consult-global-mark)
          (define-key map (kbd "i") 'consult-imenu)
          (define-key map (kbd "I") 'consult-imenu-multi)
          (define-key map (kbd "b") #'consult-bibtex)
          map))

  (setq consult-register-map
        (let ((map (make-sparse-keymap)))
          ;; Custom M-# bindings for fast register access
          (define-key map (kbd "l") 'consult-register-load)
          (define-key map (kbd "s") 'consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
          (define-key map (kbd "r") 'consult-register)
          (define-key map (kbd "b") 'consult-bookmark)
          map))
  (setq consult-mode-mode-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "h") 'consult-history)
          (define-key map (kbd "m") 'consult-mode-command)
          (define-key map (kbd "k") 'consult-kmacro)
          map))

  (setq consult-search-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "f") 'consult-find)
          (define-key map (kbd "F") 'consult-locate)
          (define-key map (kbd "g") 'consult-grep)
          (define-key map (kbd "G") 'consult-git-grep)
          (define-key map (kbd "r") 'consult-ripgrep)
          (define-key map (kbd "l") 'consult-line)
          (define-key map (kbd "L") 'consult-line-multi)
          (define-key map (kbd "m") 'consult-multi-occur)
          (define-key map (kbd "k") 'consult-keep-lines)
          (define-key map (kbd "u") 'consult-focus-lines)
          (define-key map (kbd "j") 'consult-recent-file)
          (define-key map (kbd "s") 'consult-isearch)
          map))
  (define-key global-map (kbd "M-s") consult-search-map)
  (define-key global-map (kbd "M-j") consult-goto-map)
  (define-key global-map (kbd "M-r") consult-register-map)
  (define-key global-map (kbd "M-M") consult-mode-mode-map)
  (setq consult-preview-key (kbd "C-o") ) ;; disable live preview
  (setq consult-project-root-function #'projectile-project-root)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key "<")
  :config
  (setf (alist-get 'slime-repl-mode consult-mode-histories)
        'slime-repl-input-history)
  (setq xref-show-xrefs-function #'consult-xref)
  (setq xref-show-definitions-function #'consult-xref)
  (define-key completion-list-mode-map (kbd "C-o") #'consult-preview-at-point)

  (setq completion-in-region-function #'consult-completion-in-region))

(use-package consult-dir
  :straight t
  :bind (("C-x C-d" . consult-dir)
         :map minibuffer-local-completion-map
         ("C-x C-d" . consult-dir)
         ("C-x C-j" . consult-dir-jump-file)))

(use-package consult-bibtex
  :straight (:type git :host github :repo "mohkale/consult-bibtex")
  :config
  (with-eval-after-load 'embark
    (add-to-list 'embark-keymap-alist '(bibtex-completion . consult-bibtex-embark-map)))
  (setq consult-bibtex-default-action #'consult-bibtex-edit-notes))
#+end_src
** embark

An absolute beast of a package in its design and possible use-cases. Whether you're
unmarked, in minibuffer, in an =info-mode= buffer, Embark will gather useful actions for
you to execute.

Over time I hope to have a better intuition for the situations in which this package can
shine, but for now I'm using it mostly for =embark-export= for batched editing operations.

#+begin_src emacs-lisp
(use-package embark
  :straight t
  :bind (("C->" . embark-become)
         ("M-a" . embark-act))
  :config
  (define-key completion-list-mode-map (kbd "M-a")
    #'(lambda () (interactive) () (mct-focus-mini-or-completions) (embark-act))))

(use-package embark-consult
  :straight t
  :after (embark consult)
  :demand t
  :config
  (define-key embark-collect-mode-map (kbd "o") 'consult-preview-at-point)
  ;; :hook (embark-collect-mode . embark-consult-preview-minor-mode)
  )
#+end_src

** marginalia

Enhanced minibuffer information when using =switch-to-buffer=, =find-file=,
=describe-variable=, etc.

#+begin_src emacs-lisp
(use-package marginalia
  :straight (:host github :repo "minad/marginalia" :branch "main")
  :config
  (setq marginalia-max-relative-age 0)  ; time is absolute here!
  (marginalia-mode 1))
#+end_src
** which-key

I use =which-key= to discover new useful commands hiding in a keymap prefix. That's pretty
much it, but its proven itself tremendously helpful for exploring features of the built-in
or of a new package.

#+begin_src emacs-lisp
(use-package which-key
  :straight t
  :diminish which-key-mode
  :config (which-key-mode 1))
#+end_src
** orderless

For matching symbols without regard for order, we use =orderless=.

Can be not very performant depending on the matching styles (=orderless-flex= being the
worst offender). A big configuration dream is for =orderless= to work as seamlessly as the
usual completion utilities.

When =orderless-flex= is enabled, a postfixed =,= can be used to match a literal
string, defined by the function =literal-if-comma=. To match everything but a string,
prefix the string with a "bang" =!=.

#+begin_src emacs-lisp
(use-package orderless
  :straight t
  :config
  (setq completion-styles '(orderless))
  (setq  completion-category-defaults nil
         completion-category-overrides '((file (styles . (partial-completion)))))
  (setq orderless-matching-styles '(orderless-prefixes
                                    orderless-strict-leading-initialism
                                    orderless-regexp))

  (defun literal-if-comma (pattern _index _total)
    (when (string-suffix-p "," pattern)
      `(orderless-literal . ,(substring pattern 0 -1))))

  (defun flex-if-tilde (pattern _index _total)
    (when (string-suffix-p "~" pattern)
      `(orderless-flex . ,(substring pattern 0 -1))))

  (defun initialism-if-eql (pattern _index _total)
    (when (string-suffix-p "=" pattern)
      `(orderless-strict-leading-initialism . ,(substring pattern 0 -1))))

  (defun without-if-bang (pattern _index _total)
    (cond
     ((equal "!" pattern)
      '(orderless-literal . ""))
     ((string-prefix-p "!" pattern)
      `(orderless-without-literal . ,(substring pattern 1)))))

  (setq orderless-style-dispatchers '(literal-if-comma without-if-bang flex-if-tilde initialism-if-eql))

  ;; SPC should never complete: use it for `orderless' groups.
  :bind (:map minibuffer-local-completion-map
              ("SPC" . nil)
              ("?" . nil)))
#+end_src
** abbrev, dabbrev, corfu (capf / completion framework front-ends)
#+begin_src emacs-lisp
(use-package abbrev
  :straight (:type built-in)
  :config
  (setq abbrev-suggest t)
  (setq save-abbrevs 'silently)
  (setq abbrev-file-name (locate-user-emacs-file "abbrevs"))
  (setq only-global-abbrevs nil))

(use-package dabbrev
  :config
  (define-key global-map (kbd "M-/") 'dabbrev-completion)
  (define-key global-map (kbd "C-M-/") 'dabbrev-expand)
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_") ;; same as nil technically
  (setq dabbrev-abbrev-skip-leading-regexp "[$*/=~']")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction 'case-replace)
  (setq dabbrev-case-fold-search nil)
  (setq dabbrev-case-replace 'case-replace)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines t)
  (setq dabbrev-upcase-means-case-search t))

(use-package corfu
  :disabled
  :straight t
  ;; Optional customizations
  :config
  (setq corfu-cycle t)            ;; Enable cycling for `corfu-next/previous'
  (setq corfu-auto t)             ;; Enable auto completion
  (setq corfu-quit-at-boundary t) ;; Automatically quit at word boundary
  (setq corfu-quit-no-match t)    ;; Automatically quit if there is no match
  (setq corfu-auto-delay 0.7)
  (setq corfu-echo-documentation t)
  (setq tab-always-indent 'complete)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete)
  (corfu-global-mode))

(use-package cape
  :disabled
  :straight (:type git :host github :repo "minad/cape")
  :config
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-keyword)
  (add-to-list 'completion-at-point-functions #'cape-abbrev)
  (add-to-list 'completion-at-point-functions #'cape-ispell)
  (add-to-list 'completion-at-point-functions #'cape-dict)
  (add-to-list 'completion-at-point-functions #'cape-symbol))
#+end_src
** yasnippet

nice snippets. they'll never go out of fashion

#+begin_src emacs-lisp
;; configuration
(use-package yasnippet
  :straight t
  :functions yas-global-mode yas-expand
  :diminish yas-minor-mode
  :config
  (yas-global-mode 1)
  (setq yas-fallback-behavior 'return-nil)
  (setq yas-triggers-in-field t)
  (setq yas-verbosity 0))

(use-package yasnippet-snippets
  :straight t)
#+end_src

** xref
Its debateable whether xref should be in this section. May re-evaluate in future

#+BEGIN_SRC emacs-lisp
(use-package xref
  :straight (:type built-in)
  :config
  ;; All those have been changed for Emacs 28
  (setq xref-show-definitions-function #'xref-show-definitions-completing-read) ; for M-.
  (setq xref-show-xrefs-function #'xref-show-definitions-buffer) ; for grep and the like
  (setq xref-file-name-display 'project-relative)
  (setq xref-search-program 'ripgrep)
  )
#+END_SRC

* programming languages and environments
** General Prog Mode
#+begin_src emacs-lisp
;; Mark TODOs , FIXME, BUG as red in src code
(add-hook 'prog-mode-hook
          (lambda ()
            (font-lock-add-keywords
             nil
             '(("\\<\\(FIXME\\|TODO\\|BUG\\)" 1 font-lock-warning-face prepend)))))
#+end_src
** eglot
#+begin_src emacs-lisp
(use-package eglot
  :straight t
  :config
  (defvar eglot-prog-mode-hooks '(python-mode-hook cc-mode-hook c-mode-hook c++-mode-hook cuda-mode-hook
                                                   c-common-mode-hook julia-mode-hook rjsx-mode-hook
                                                   typescript-mode-hook tuareg-mode-hook))
  (dolist (mode eglot-prog-mode-hooks)
    (add-hook mode 'eglot-ensure))

  (define-key eglot-mode-map (kbd "C-c y n") #'eglot-rename)
  (define-key eglot-mode-map (kbd "C-c y n") #'eglot-rename)
  (define-key eglot-mode-map (kbd "C-c y o") #'eglot-reconnect)
  (define-key eglot-mode-map (kbd "C-c y a") #'eglot-code-actions)
  (define-key eglot-mode-map (kbd "C-c y b") #'eglot-format-buffer)
  (define-key eglot-mode-map (kbd "C-c y h") #'eldoc)

  ;; i don't relaly like flymake, this issue
  ;; https://github.com/joaotavora/eglot/issues/42

  ;; corfu can be weird man.
  (eval-after-load "corfu"
    (progn
      (defun corfu-eglot-setup ()
        (setq-local completion-styles '(orderless)
                    completion-category-defaults nil))

      (add-hook 'eglot-mode-hook #'corfu-eglot-setup))))

(use-package eglot-jl
  :straight t
  :config
  (eglot-jl-init)
  (setq eglot-connect-timeout 100)
  )

(use-package consult-eglot
  :straight t
  :config
  (define-key eglot-mode-map [remap xref-find-apropos] #'consult-eglot-symbols)
  (define-key eglot-mode-map (kbd "C-c y l") #'consult-flymake))

;; meh hack from here to use flycheck in eglot

;; https://gist.github.com/purcell/ca33abbea9a98bb0f8a04d790a0cadcd
;; might try flymake for a change

;; (defvar-local flycheck-eglot-current-errors nil)

;; (defun flycheck-eglot-report-fn (diags &rest _)
;;   (setq flycheck-eglot-current-errors
;;         (mapcar (lambda (diag)
;;                   (save-excursion
;;                     (goto-char (flymake--diag-beg diag))
;;                     (flycheck-error-new-at (line-number-at-pos)
;;                                            (1+ (- (point) (line-beginning-position)))
;;                                            (pcase (flymake--diag-type diag)
;;                                              ('eglot-error 'error)
;;                                              ('eglot-warning 'warning)
;;                                              ('eglot-note 'info)
;;                                              (_ (error "Unknown diag type, %S" diag)))
;;                                            (flymake--diag-text diag)
;;                                            :checker 'eglot)))
;;                 diags))
;;   (flycheck-buffer))

;; (defun flycheck-eglot--start (checker callback)
;;   (funcall callback 'finished flycheck-eglot-current-errors))

;; (defun flycheck-eglot--available-p ()
;;   (bound-and-true-p eglot--managed-mode))

;; (flycheck-define-generic-checker 'eglot
;;   "Report `eglot' diagnostics using `flycheck'."
;;   :start #'flycheck-eglot--start
;;   :predicate #'flycheck-eglot--available-p
;;   :modes '(prog-mode text-mode))

;; (push 'eglot flycheck-checkers)

;; (defun sanityinc/eglot-prefer-flycheck ()
;;   (when eglot--managed-mode
;;     (flycheck-add-mode 'eglot major-mode)
;;     (flycheck-select-checker 'eglot)
;;     (flycheck-mode)
;;     (flymake-mode -1)
;;     (setq eglot--current-flymake-report-fn 'flycheck-eglot-report-fn)))

;; (add-hook 'eglot--managed-mode-hook 'sanityinc/eglot-prefer-flycheck)
#+end_src
** ocaml
#+begin_src emacs-lisp
(use-package tuareg
  :straight t)

(use-package utop
  :straight t
  :config
  (setq utop-command "opam config exec -- utop -emacs")
  (autoload 'utop-minor-mode "utop" "Minor mode for utop" t)
  (add-hook 'tuareg-mode-hook 'utop-minor-mode)
  )
#+end_src
** python
#+begin_src emacs-lisp
(use-package python
  :straight t
  :after flycheck
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode)
  :config
  (setq python-indent-offset 4)
  (setq python-shell-interpreter "ipython"
        ;; python-shell-interpreter-args "console --simple-prompt"
        python-shell-prompt-detect-failure-warning nil)
  ;; (add-to-list 'python-shell-completion-native-disabled-interpreters
  ;;              "jupyter")
  (custom-set-variables
   '(flycheck-python-flake8-executable "python3")
   '(flycheck-python-pycompile-executable "python3")
   '(flycheck-python-pylint-executable "python3"))
  (flycheck-add-next-checker 'python-flake8 'python-mypy t)
  )

(use-package pyvenv
  :straight t)
                                        ; optional: if Org Ref is not loaded anywhere else, load it here
#+end_src

** julia
#+begin_src emacs-lisp
(use-package julia-mode
  :straight t)

(use-package vterm
  :straight t)

(use-package julia-snail
  :straight t
  :config
  (add-hook 'julia-mode-hook 'julia-snail-mode))
#+end_src

** c{,++} environment
#+begin_src emacs-lisp
(use-package cc-mode
  :hook
  (c-common-mode-hook . hs-minor-mode)
  :config
  (setq gdb-many-windows 't)
  (setq compilation-ask-about-save nil)
  (setq compilation-scroll-output 'next-error)
  (setq compilation-skip-threshold 2)

  (setq tab-width 4)
  (setq c-basic-offset 4)
  (setq-default indent-tabs-mode nil)

  (define-key c-mode-map (kbd "C-j") 'c-indent-new-comment-line)
  (define-key c++-mode-map (kbd "C-j") 'c-indent-new-comment-line)
  (add-hook 'c++-mode-hook
            #'(lambda ()
                (setq compile-command "cmake .. -DCMAKE_EXRORT_COMPILE_COMMANDS=1 -DCMAKE_BUILD_TYPE=Debug; make clean; cmake --build . -j8")
                ))
  (unbind-key (kbd "C-M-q") c-mode-map)
  (unbind-key (kbd "C-M-q") c++-mode-map)
  )

(use-package gud
  :after cc-mode
  :config
  (setq gud-nav-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "g b") 'gud-break)
          (define-key map (kbd "g <") 'gud-up)
          (define-key map (kbd "g >") 'gud-down)
          (define-key map (kbd "g n") 'gud-next)
          (define-key map (kbd "g s") 'gud-step)
          (define-key map (kbd "g c") 'gud-cont)
          (define-key map (kbd "g p") 'gud-print)
          (define-key map (kbd "g d") 'gud-remove)
          (define-key map (kbd "g l") 'gud-refresh)
          (define-key map (kbd "g e") 'gud-statement)
          map))
  (define-key c-mode-map (kbd "C-c C-g") gud-nav-map)
  (define-key c++-mode-map (kbd "C-c C-g") gud-nav-map))

(use-package cmake-mode
  :straight t)

(use-package eldoc-cmake
  :straight t
  :hook (cmake-mode-hook . eldoc-cmake-enable))
#+end_src
** symbolic math (maxima, calc)
#+begin_src emacs-lisp
(use-package calc)
(use-package maxima
  :straight (:type git :host gitlab :repo "sasanidas/maxima")
  :init
  (add-hook 'maxima-mode-hook #'maxima-hook-function)
  (add-hook 'maxima-inferior-mode-hook #'maxima-hook-function)
  (setq maxima-display-maxima-buffer t)
  :mode ("\\.mac\\'" . maxima-mode)
  :interpreter ("maxima" . maxima-mode))
#+end_src

** docker
#+begin_src emacs-lisp
(use-package dockerfile-mode
  :straight t)
#+end_src

** lisp and scheme
#+begin_src emacs-lisp
(use-package sly
  :straight t
  :config
  (setq inferior-lisp-program "/usr/bin/sbcl"))

(use-package sly-asdf
  :straight t)

(use-package sly-quicklisp
  :straight t)

;; eldoc provides minibuffer hints for elisp things. it's super nice
(use-package eldoc
  :straight t
  :diminish eldoc-mode
  :config
  (global-eldoc-mode 1))

;; paren stuff
(use-package lispy
  :straight t
  :diminish lispy-mode
  :hook ((emacs-lisp-mode-hook scheme-mode-hook lisp-mode-hook) . lispy-mode))

(use-package rainbow-delimiters
  :straight t
  :diminish rainbow-delimiters-mode
  :init
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

(use-package geiser
  :straight t)

(use-package geiser-chez
  :straight t
  :config
  (require 'geiser-chez))

(add-to-list 'auto-mode-alist
             '("\\.sc\\'" . scheme-mode))

(add-to-list 'auto-mode-alist
             '("\\.sls\\'" . scheme-mode)
             '("\\.sps\\'" . scheme-mode))
(unbind-key (kbd "C-M-q") scheme-mode-map)
#+end_src
** flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :straight t
  :diminish flycheck-mode
  :init (add-hook 'prog-mode-hook 'flycheck-mode)
  :config
  (setq flycheck-indication-mode nil)
  ;; set up simple cache so the checker isn't linear searching the (very many) checkers if it needs one
  (defvar-local my/flycheck-local-cache nil)
  (defun my/flycheck-checker-get (fn checker property)
    (or (alist-get property (alist-get checker my/flycheck-local-cache))
        (funcall fn checker property)))
  (advice-add 'flycheck-checker-get :around 'my/flycheck-checker-get)

  ;; set up mypy for flycheck in setting up typed python
  ;;; [2021-12-26 Sun] I've moved to eglot and have yet to used typed python in a while. not sure if there's more to do here.
  ;; (add-hook 'lsp-managed-mode-hook
  ;;           (lambda ()
  ;;             (when (derived-mode-p 'python-mode)
  ;;               (setq my/flycheck-local-cache '((lsp . ((next-checkers . (python-mypy)))))))))

  (setq error-search-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "n") 'next-error)
          (define-key map (kbd "p") 'previous-error)
          (define-key map (kbd "d") 'flycheck-display-error-at-point)
          (define-key map (kbd "l") 'consult-flycheck)
          (define-key map (kbd "L") 'flycheck-list-errors)
          (define-key map (kbd "c") 'flycheck-compile)
          (define-key map (kbd "w") 'flycheck-copy-errors-as-kill)
          map))
  (define-key global-map (kbd "C-c y e") error-search-map))

(use-package consult-flycheck
  :straight (:type git :host github :repo "minad/consult-flycheck"))
#+end_src
* unix environment interface
** magit and vc
#+begin_src emacs-lisp
;;; Magit
;; God bless magit and all that it does
(use-package magit
  :straight t
  :commands magit-status magit-blame
  :config
  (setq
   ;; don't put "origin-" in front of new branch names by default
   magit-default-tracking-name-function 'magit-default-tracking-name-branch-only
   magit-push-always-verify nil)
  (define-key global-map (kbd "C-x g") 'magit-status))

;; More info here: [[https://github.com/syohex/emacs-git-gutter]]
(use-package git-gutter ; TODO - git gutter keybinds, going to different hunks and staging only certain portions!
  :straight t
  :diminish git-gutter-mode
  :config
  (global-git-gutter-mode +1))

(use-package projectile
  :straight t
  :diminish
  :config
  (projectile-global-mode)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))

(use-package vc
  :straight (:type built-in)
  :config
  (setq vc-handled-backends '(SVN Git))
  ;;;  As always, from Prot. Directly copied. No shame. See https://protesilaos.com/emacs/dotemacs#h:31deeff4-dfae-48d9-a906-1f3272f29bc9

  ;; Those offer various types of functionality, such as blaming,
  ;; viewing logs, showing a dedicated buffer with changes to affected
  ;; files.
  (require 'vc-annotate)
  (require 'vc-dir)
  (require 'vc-git)
  (require 'add-log)
  (require 'log-view)

  ;; This one is for editing commit messages.
  (require 'log-edit)
  (setq log-edit-confirm 'changed)
  (setq log-edit-keep-buffer nil)
  (setq log-edit-require-final-newline t)
  (setq log-edit-setup-add-author nil)

  ;; Note that `prot-vc-git-setup-mode' will run the following when
  ;; activated:
  ;;
  ;;   (remove-hook 'log-edit-hook #'log-edit-show-files)
  ;;
  ;; If you need the window to pop back up, do it manually with C-c C-f
  ;; which calls `log-edit-show-files'.

  (setq vc-find-revision-no-save t)
  (setq vc-annotate-display-mode 'scale) ; scale to oldest
  ;; I use a different account for git commits
  ;; (setq add-log-mailing-address "info@protesilaos.com")
  (setq add-log-keep-changes-together t)
  (setq vc-git-diff-switches '("--patch-with-stat" "--histogram"))
  (setq vc-git-print-log-follow t)
  (setq vc-git-revision-complete-only-branches nil) ; Emacs 28
  (setq vc-git-root-log-format
        '("%d %h %ad %an: %s"
          ;; The first shy group matches the characters drawn by --graph.
          ;; We use numbered groups because `log-view-message-re' wants the
          ;; revision number to be group 1.
          "^\\(?:[*/\\|]+\\)\\(?:[*/\\| ]+\\)?\
\\(?2: ([^)]+) \\)?\\(?1:[0-9a-z]+\\) \
\\(?4:[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\) \
\\(?3:.*?\\):"
          ((1 'log-view-message)
           (2 'change-log-list nil lax)
           (3 'change-log-name)
           (4 'change-log-date))))

  (add-hook 'log-view-mode-hook #'hl-line-mode)

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v b") #'vc-retrieve-tag)  ; "branch" switch
    (define-key map (kbd "C-x v t") #'vc-create-tag)
    (define-key map (kbd "C-x v f") #'vc-log-incoming)  ; the actual git fetch
    (define-key map (kbd "C-x v o") #'vc-log-outgoing)
    (define-key map (kbd "C-x v F") #'vc-update)        ; "F" because "P" is push
    (define-key map (kbd "C-x v d") #'vc-diff))
  (let ((map vc-dir-mode-map))
    (define-key map (kbd "b") #'vc-retrieve-tag)
    (define-key map (kbd "t") #'vc-create-tag)
    (define-key map (kbd "O") #'vc-log-outgoing)
    (define-key map (kbd "o") #'vc-dir-find-file-other-window)
    (define-key map (kbd "f") #'vc-log-incoming) ; replaces `vc-dir-find-file' (use RET)
    (define-key map (kbd "F") #'vc-update)       ; symmetric with P: `vc-push'
    (define-key map (kbd "d") #'vc-diff)         ; parallel to D: `vc-root-diff'
    (define-key map (kbd "k") #'vc-dir-clean-files)
    (define-key map (kbd "G") #'vc-revert)
    (let ((prot-vc-git-branch-map (make-sparse-keymap)))
      (define-key map "B" prot-vc-git-branch-map)
      (define-key prot-vc-git-branch-map "n" #'vc-create-tag) ; new branch/tag
      (define-key prot-vc-git-branch-map "s" #'vc-retrieve-tag) ; switch branch/tag
      ;; (define-key prot-vc-git-branch-map "c" #'prot-vc-git-checkout-remote)
                                        ; "checkout" remote
      (define-key prot-vc-git-branch-map "l" #'vc-print-branch-log))
    (let ((prot-vc-git-stash-map (make-sparse-keymap)))
      (define-key map "S" prot-vc-git-stash-map)
      (define-key prot-vc-git-stash-map "c" 'vc-git-stash) ; "create" named stash
      (define-key prot-vc-git-stash-map "s" 'vc-git-stash-snapshot)))
  (let ((map vc-git-stash-shared-map))
    (define-key map "a" 'vc-git-stash-apply-at-point)
    (define-key map "c" 'vc-git-stash) ; "create" named stash
    (define-key map "D" 'vc-git-stash-delete-at-point)
    (define-key map "p" 'vc-git-stash-pop-at-point)
    (define-key map "s" 'vc-git-stash-snapshot))
  (let ((map vc-annotate-mode-map))
    (define-key map (kbd "M-q") #'vc-annotate-toggle-annotation-visibility)
    (define-key map (kbd "C-c C-c") #'vc-annotate-goto-line)
    (define-key map (kbd "<return>") #'vc-annotate-find-revision-at-line))
  (let ((map log-view-mode-map))
    (define-key map (kbd "<tab>") #'log-view-toggle-entry-display)
    (define-key map (kbd "<return>") #'log-view-find-revision)
    (define-key map (kbd "s") #'vc-log-search)
    (define-key map (kbd "o") #'vc-log-outgoing)
    (define-key map (kbd "f") #'vc-log-incoming)
    (define-key map (kbd "F") #'vc-update)
    (define-key map (kbd "P") #'vc-push))


  )
#+end_src
** eshell
#+begin_src emacs-lisp
(use-package eshell
  :init
  (require 'esh-mode)
  (require 'esh-module)
  (setq eshell-modules-list             ; It works but may need review
        '(eshell-alias
          eshell-basic
          eshell-cmpl
          eshell-dirs
          eshell-glob
          eshell-hist
          eshell-ls
          eshell-pred
          eshell-prompt
          eshell-script
          eshell-term
          eshell-tramp
          eshell-unix))
  (setenv "PAGER" "cat") ; solves issues, such as with 'git log' and the default 'less'
  (require 'em-cmpl)
  (require 'em-dirs)
  (setq eshell-cd-on-directory t)

  (require 'em-tramp)
  (setq password-cache t)
  (setq password-cache-expiry 600)

  (require 'em-hist)
  (setq eshell-hist-ignoredups t)
  (setq eshell-save-history-on-exit t)

  (setq eshell-buffer-shorthand t
        eshell-destroy-buffer-when-process-dies t)
  :bind ("<f1>" . eshell))
#+end_src
** shell
#+begin_src emacs-lisp
(use-package shell
  :straight (:type built-in)
  :config
  (setq shell-command-prompt-show-cwd t) ; Emacs 27.1
  (setq ansi-color-for-comint-mode t))
#+end_src
** proced (top for emacs)
#+begin_src emacs-lisp
(use-package proced
  :straight (:type built-in)
  :init
  (setq proced-auto-update-flag t)
  (setq proced-auto-update-interval 5)
  (setq proced-descend t)
  (setq prcoed-filter 'user))
#+end_src

** dired
starting from prot's configuration since he always RTFMs. And I don't...
#+begin_src emacs-lisp
(use-package dired
  :config
  (add-hook 'dired-mode-hook
            (lambda ()
              (dired-hide-details-mode 1)))

  ;; disable ls by default
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
        "-AGFhlv --group-directories-first --time-style=long-iso")
  (setq dired-dwim-target t)
  (setq dired-auto-revert-buffer #'dired-directory-changed-p) ; also see `dired-do-revert-buffer'
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (add-hook 'dired-mode-hook #'hl-line-mode))

(use-package dired-aux
  :straight (:type built-in)
  :config
  (setq dired-isearch-filenames 'dwim)
  ;; The following variables were introduced in Emacs 27.1
  (setq dired-create-destination-dirs 'ask)
  (setq dired-vc-rename-file t)
  ;; And this is for Emacs 28
  (setq dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir))))

  (let ((map dired-mode-map))
    (define-key map (kbd "C-+") #'dired-create-empty-file)
    (define-key map (kbd "M-s f") #'nil)
    (define-key map (kbd "C-x v v") #'dired-vc-next-action))
  )
(use-package dired-x
  :straight (:type built-in)
  :config
  (setq dired-clean-up-buffers-too t)
  (setq dired-clean-confirm-killing-deleted-buffers t)
  (setq dired-x-hands-off-my-keys t)    ; easier to show the keys I use
  (setq dired-bind-man nil)
  (setq dired-bind-info nil)
  (define-key dired-mode-map (kbd "I") #'dired-info))
#+end_src
** recentf, wgrep
#+begin_src emacs-lisp
(use-package recentf                    ; Save recently visited files
  :init (recentf-mode)
  :diminish recentf-mode
  :config
  (setq
   recentf-max-saved-items 200
   recentf-max-menu-items 15
   ;; Cleanup recent files only when Emacs is idle, but not when the mode
   ;; is enabled, because that unnecessarily slows down Emacs. My Emacs
   ;; idles often enough to have the recent files list clean up regularly
   recentf-auto-cleanup 300
   recentf-exclude (list "/\\.git/.*\\'"     ; Git contents
                         "/elpa/.*\\'"       ; Package files
                         "/itsalltext/"      ; It's all text temp files
                         ;; And all other kinds of boring files
                         )))

(use-package wgrep
  :straight t
  :bind
  (:map grep-mode-map
        ("C-x C-q" . wgrep-change-to-wgrep-mode)
        ("C-c C-p" . wgrep-change-to-wgrep-mode)))
#+end_src
** ediff
#+begin_src emacs-lisp
(use-package ediff
  :diminish ediff-mode
  :custom
  (ediff-diff-options "-w"))
#+end_src
** exec path from shell
#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :straight t
  :config
  (exec-path-from-shell-initialize))
#+end_src

** Transparent Remote (file) Access, Multiple Protocol (TRAMP)

The manual walks through a number of examples that demonstrate the hidden processes that
TRAMP does so the user doesn't have to. The most sensible methods that I use are =ssh=
(unix based) and =smb= (windows, samba).

There's a couple of typical uses that are nice to have written down (more examples in [[info:tramp#File name
 syntax][tramp#File name syntax]]):
- =/-::= -- Use the default TRAMP method and connect to the local host with the current
  username
- =/ssh:domain:= -- Use the =ssh= method to connect to domain name =domain=. =domain= can be
  an an IPv4, an IPv6, or a resolvable domain name address.
- =/ssh:username@domain:= -- connect to =domain= with the user =username=. This will
  prompt a login sequence if no token or key is already registered.
- =/ssh:username@domain|sudo::/path/to/file= connect to =domain= with username =username=,
  to then tunnel into a =localhost= connection for =sudo=.
- =/ssh:username@domain#port:= -- Connect to =domain= for user =username= on the port
  =port=. This can be especially useful if tunneling occurs on specific open ports
  (usually something like =:22= but could be different). Equivalent to =ssh -p PORT=. 

There is a distinction between =inline= and =external= methods. The inline methods include
the ubiquitous =ssh=. External methods include =scp=, =rsync=, =ftp=, =smb= and so
forth. Details on =smb= can be checked in [[info:tramp#External methods][the manual]]. =inline= methods should be used
first since they generally work well with small files. =external= methods can be used
after finding =internal= methods insufficient.

To avoid repeated authentication, native caching mechanisms can be used and are generally
prompted for in the natural TRAMP usage. Another package =auth-source.el= reads passwords
from different sources stored in the default authentication file =~/.authinfo{,.gpg}= (but
can be changed through the variable =auth-sources=). See [[info:auth#Help for users][auth#Help for users]] for more
information on the format of this file and the details that =auth-source= goes through to
access it.

The usual very capable built-in packages interop well with tramp: =shell.el=, =eshell.el=,
=compile.el= (commands like =compile= and =grep=) and =gud.el= (=gdb= or =perldb=). The
most typical problem with these packages will be the problem with the remote =PATH= found
by tramp (configurable through =tramp-remote-path=). This can help find programs in, say
=~/.local/bin/, ~/bin=.

=DISPLAY= can be problematic. [[info:tramp#Remote processes][tramp#Remote processes]] has some details. The upshot is that
the =tramp-remote-process-environment= needs to have the variable =DISPLAY=(getenv
"DISPLAY")= set (if X11 is configured properly on the hosting shell). You can also specify
=ForwardX11 yes= or =ForwardX11Trusted yes= in =~/.ssh/config=.

External =shell-command= usages use the remote host's file path system (not the
=/ssh:host:...= system specified by tramp). =shell-command= will infer the host on which
it is being used so that the relative file path is always "correct", given that you know
the machine you're on.

=eshell= has very tight interop with TRAMP. You can simply run =cd /sudo::/etc= to enter
the local =/etc= directory in =sudo= mode. Any TRAMP file specification can be used to
seamlessly remote in the eshell session.

Running =gdb= through =gud.el= can be done, but as opposed to =shell-command= the TRAMP
naming system must be used: =gdb -i=mi /ssh:host:~/program <RET>=. I/O will be restricted
since =gdb= and =gdb-inferior= will not belong to the same process group on the remote
host. Relative file paths are possible as well, but when in doubt the full path should be
the go-to.


_Using tramp with docker_:
...


#+begin_src emacs-lisp
(use-package tramp
  :straight (:type built-in)
  :config
  ;;; I'm actually going to give scp a try as the default method for now. There might be benefits due to the encryption overhead required of ssh in =external= use cases.

  ;; ssh > scp (the default).
  ;; (setq tramp-default-method "ssh")
  ;; (setq tramp-default-user "packell1")

  (setq tramp-verbose 3) ;; can go up to 11! 3 is the default.
  )
#+end_src
* external environment interface
** notmuch, mail in emacs
#+begin_src emacs-lisp
(use-package notmuch
  :straight t
  :config
  (setq notmuch-show-logo nil)
  (setq notmuch-column-control t)
  (setq notmuch-hello-auto-refresh t)
  (setq notmuch-hello-recent-searches-max 20)
  (setq notmuch-hello-thousands-separator "")
  ;; ;; See my variant of it in `prot-notmuch' below.
  (setq notmuch-hello-sections '(notmuch-hello-insert-saved-searches))
  (setq notmuch-show-all-tags-list t)

  (setq notmuch-search-oldest-first nil)

  (setq notmuch-search-line-faces
        '(("unread" . notmuch-search-unread-face)
          ("flag" . notmuch-search-flagged-face)))
  (setq notmuch-show-empty-saved-searches t)

  (setq notmuch-saved-searches
        `(( :name "all"
            :query "not tag:archived and not tag:list and not tag:lists and not tag:spam"
            :sort-order newest-first
            :key ,(kbd "a"))
          ( :name "inbox"
            :query "tag:inbox not tag:archived"
            :sort-order newest-first
            :key ,(kbd "i"))
          ( :name "unread (inbox)"
            :query "tag:unread and tag:inbox"
            :sort-order newest-first
            :key ,(kbd "u"))
          ( :name "unread all"
            :query "tag:unread and not tag:archived and not tag:list and not tag:lists"
            :sort-order newest-first
            :key ,(kbd "U"))
          ( :name "personal"
            :query "tag:personal not tag:archived"
            :sort-order newest-first
            :key ,(kbd "p"))
          ( :name "personal all"
            :query "tag:personal"
            :sort-order newest-first
            :key ,(kbd "P"))
          ( :name "todo"
            :query "tag:todo not tag:archived"
            :sort-order newest-first
            :key ,(kbd "t"))
          ( :name "todo all"
            :query "tag:todo"
            :sort-order newest-first
            :key ,(kbd "T"))
          ( :name "done"
            :query "tag:done"
            :sort-order newest-first
            :key ,(kbd "d"))
          ( :name "flagged"
            :query "tag:flag or tag:flagged or tag:important or tag:starred"
            :sort-order newest-first
            :key ,(kbd "f"))
          ( :name "mailing lists"
            :query "tag:list or tag:lists not tag:archived"
            :key ,(kbd "m"))
          ))

  (setq notmuch-archive-tags '("-inbox" "+archived"))
  (setq notmuch-message-replied-tags '("+replied"))
  (setq notmuch-message-forwarded-tags '("+forwarded"))
  (setq notmuch-show-mark-read-tags '("-unread"))
  (setq notmuch-draft-tags '("+draft"))
  (setq notmuch-draft-folder "drafts")
  (setq notmuch-draft-save-plaintext 'ask)

  ;; ;; NOTE 2021-06-18: See an updated version in the `prot-notmuch'
  ;; ;; section below.
  (setq notmuch-tagging-keys
        `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
          (,(kbd "c") ("+archived" "-inbox" "-list" "-todo" "-ref" "-unread" "+done") "Complete and archive")
          (,(kbd "d") ("+del" "-inbox" "-archived" "-unread") "Mark for deletion")
          (,(kbd "f") ("+flag" "-unread") "Flag as important")
          ;; (,(kbd "r") notmuch-show-mark-read-tags "Mark as read")
          (,(kbd "r") ("+ref" "+notes" "-unread") "Reference for the future")
          (,(kbd "s") ("+spam" "+del" "-inbox" "-unread") "Mark as spam")
          (,(kbd "t") ("+todo" "-unread") "To-do")
          (,(kbd "u") ("+unread") "Mark as unread")))

  (setq notmuch-tag-formats
        '(("unread" (propertize tag 'face 'notmuch-tag-unread))
          ("flag" (propertize tag 'face 'notmuch-tag-flagged))))
  (setq notmuch-tag-deleted-formats
        '(("unread" (notmuch-apply-face bare-tag `notmuch-tag-deleted))
          (".*" (notmuch-apply-face tag `notmuch-tag-deleted))))

;;; Email composition
  (setq notmuch-mua-compose-in 'current-window)
  (setq notmuch-mua-hidden-headers nil) ; TODO 2021-05-12: Review hidden headers
  (setq notmuch-address-command nil)    ; FIXME 2021-05-13: Make it work with EBDB
  (setq notmuch-always-prompt-for-sender t)
  (setq notmuch-mua-cite-function 'message-cite-original-without-signature)
  (setq notmuch-mua-reply-insert-header-p-function 'notmuch-show-reply-insert-header-p-never)
  (setq notmuch-mua-user-agent-function #'notmuch-mua-user-agent-full)
  (setq notmuch-maildir-use-notmuch-insert t)
  (setq notmuch-crypto-process-mime t)
  (setq notmuch-crypto-get-keys-asynchronously t)
  (setq notmuch-mua-attachment-regexp   ; see `notmuch-mua-send-hook'
        (concat "\\b\\(attache\?ment\\|attached\\|attach\\)"
                "\\b"))

;;; Reading messages
  (setq notmuch-show-relative-dates t)
  (setq notmuch-show-all-multipart/alternative-parts nil)
  (setq notmuch-show-indent-messages-width 0)
  (setq notmuch-show-indent-multipart nil)
  (setq notmuch-show-part-button-default-action 'notmuch-show-save-part)
  (setq notmuch-show-text/html-blocked-images ".") ; block everything
  (setq notmuch-wash-citation-lines-prefix 6)
  (setq notmuch-wash-citation-lines-suffix 6)
  (setq notmuch-wash-wrap-lines-length 100)
  (setq notmuch-unthreaded-show-out nil)
  (setq notmuch-message-headers '("To" "Cc" "Subject" "Date"))
  (setq notmuch-message-headers-visible t)

;;; Hooks and key bindings
  (add-hook 'notmuch-mua-send-hook #'notmuch-mua-attachment-check)
  (remove-hook 'notmuch-show-hook #'notmuch-show-turn-on-visual-line-mode)
  (add-hook 'notmuch-show-hook (lambda () (setq-local header-line-format nil)))

  ;; Use alternating backgrounds, if `stripes' is available.
  (with-eval-after-load 'stripes
    (add-hook 'notmuch-search-hook #'stripes-mode)
    ;; ;; To disable `hl-line-mode':
    ;; (setq notmuch-search-hook nil)
    ;; (add-hook 'notmuch-search-hook #'prot-common-disable-hl-line)
    )

  (let ((map global-map))
    (define-key map (kbd "C-c m") #'notmuch)
    (define-key map (kbd "C-x m") #'notmuch-mua-new-mail)) ; override `compose-mail'
  (define-key notmuch-search-mode-map (kbd "/") #'notmuch-search-filter) ; alias for l
  (define-key notmuch-hello-mode-map (kbd "C-<tab>") nil)
  )


;;; Sending email (SMTP)
(use-package smtpmail
  :config
  (setq smtpmail-stream-type 'ssl)
  (setq smtpmail-smtp-service 465)
  (setq smtpmail-queue-mail nil)
  (setq smtpmail-smtp-server "smtp.gmail.com")
  ;; (setq smtpmail-auth-credentials '(("smtp.gmail.com" 465 "liampacker@gmail.com" "acydhqtbgeudyvxm")))
  (setq smtpmail-debug-info t)
  (setq smtpmail-debug-verb t)
  )

(use-package sendmail
  :config
  (setq send-mail-function 'smtpmail-send-it))
#+END_SRC

** eww, web browsing
#+begin_src emacs-lisp
(use-package eww
  :straight (:type built-in)
  :config
  (define-key global-map (kbd "<f12>") 'eww)
  (setq shr-use-colors nil)             ; t is bad for accessibility
  (setq shr-use-fonts nil)              ; t is not for me
  (setq shr-max-image-proportion 0.6)
  (setq shr-image-animate nil)          ; No GIFs, thank you!
  (setq shr-width nil)                  ; check `prot-eww-readable'
  (setq shr-discard-aria-hidden t)
  (setq shr-cookie-policy nil)

  (setq eww-search-prefix "https://www.google.com/search?q=")

  (setq browse-url-browser-function 'eww-browse-url)
  (setq browse-url-secondary-browser-function 'browse-url-default-browser)
  (setq eww-restore-desktop t)
  (setq eww-desktop-remove-duplicates t)
  (setq eww-header-line-format nil)
  (setq eww-download-directory (expand-file-name "~/Documents/eww-downloads"))
  (setq eww-suggest-uris
        '(eww-links-at-point
          thing-at-point-url-at-point))
  (setq eww-bookmarks-directory (locate-user-emacs-file "eww-bookmarks/"))
  (setq eww-history-limit 150)
  (setq eww-browse-url-new-window-is-tab nil)
  (setq eww-form-checkbox-selected-symbol "[X]")
  (setq eww-form-checkbox-symbol "[ ]")
  (setq eww-retrieve-command nil)

  (define-key eww-link-keymap (kbd "v") nil) ; stop overriding `eww-view-source'
  (define-key eww-mode-map (kbd "L") #'eww-list-bookmarks)
  (define-key dired-mode-map (kbd "E") #'eww-open-file) ; to render local HTML files
  (define-key eww-buffers-mode-map (kbd "d") #'eww-bookmark-kill)   ; it actually deletes
  (define-key eww-bookmark-mode-map (kbd "d") #'eww-bookmark-kill) ; same
  )
#+end_src
** elfeed, RSS feed reader

#+begin_src emacs-lisp
(use-package elfeed
  :straight t
  :config
  (define-key global-map (kbd "C-c e") #'elfeed)

  (setq elfeed-use-curl t)
  (setq elfeed-curl-max-connections 10)
  (setq elfeed-db-directory (concat user-emacs-directory "elfeed/"))
  (setq elfeed-enclosure-default-dir "~/Downloads/")
  (setq elfeed-search-filter "@4-months-ago +unread")
  (setq elfeed-sort-order 'descending)
  (setq elfeed-search-clipboard-type 'CLIPBOARD)
  (setq elfeed-search-title-max-width 110)
  (setq elfeed-search-title-min-width 30)
  (setq elfeed-search-trailing-width 25)
  (setq elfeed-show-truncate-long-urls t)
  (setq elfeed-show-unique-buffers t)
  (setq elfeed-search-date-format '("%F %R" 16 :left))

  (let ((map elfeed-search-mode-map))
    (define-key map (kbd "w") #'elfeed-search-yank)
    (define-key map (kbd "g") #'elfeed-update)
    (define-key map (kbd "G") #'elfeed-search-update--force)) ; "hop" mnemonic
  (let ((map elfeed-show-mode-map))
    (define-key map (kbd "w") #'elfeed-show-yank))
  ;; Make sure to also check the section on shr and eww for how I handle
  ;; `shr-width' there.
  (add-hook 'elfeed-show-mode-hook
            (lambda () (setq-local shr-width (max 80 (current-fill-column)))))

  ;; This is set in two places now, once in =eww= and once here.
  (setq browse-url-browser-function 'eww-browse-url)
  (setq browse-url-secondary-browser-function 'browse-url-default-browser)
  (setq elfeed-feeds '(("https://freddiedeboer.substack.com/feed.rss" leftist) ;; marxist i think
                       ("https://www.juliabloggers.com/feed/" julia ) ;; julia blogs
                       ("https://protesilaos.com/master.xml" leftist philosphy emacs)
                       ("https://hnrss.org/newest?points=100" hacker-news tech)
                       "https://dynomight.net/feed.xml"
                       ("https://computer.rip/rss.xml" tech) ;; "computers are bad
                       ("http://rachelbythebay.com/w/2021/11/06/sql/" tech)
                       ("https://matt.might.net/articles/feed.rss" tech academia pl)
                       ("https://www.nayuki.io/rss20.xml" hacker)
                       ("https://ava.substack.com/feed" writing help-self)
                       ("https://askmolly.substack.com/feed" writing help-self)
                       ("https://askpolly.substack.com/feed" writing help-self)
                       ("https://cherylstrayed.substack.com/feed" writing help-self)
                       ("https://griefbacon.substack.com/feed" writing)
                       ("https://leandramcohen.substack.com/feed" fashion)
                       ("https://defaultfriend.substack.com/feed" writing)
                       ("https://jdahl.substack.com/feed" writing)
                       ("http://feeds.feedburner.com/FineArtAndYou" art)
                       ("http://inconvergent.net/atom.xml" infrequent)
                       ("http://nullprogram.com/feed/" infrequent)
                       ("http://feeds.feedburner.com/datacolada/" infrequent)
                       ("https://terrytao.wordpress.com/feed/" math)
                       ("http://xkcd.com/rss.xml" comic)
                       ("http://feeds.feedburner.com/RoguelikeRadio" infrequent)
                       ("http://cppcast.libsyn.com/rss" cpp)
                       ("http://planet.emacsen.org/atom.xml" lisp) ;; emacs
                       ("https://planet.lisp.org/rss20.xml" lisp) ;; lisp
                       ("https://tymoon.eu/api/reader/atom" lisp) ;; lisp, gamedev
                       ("https://40ants.com/lisp-project-of-the-day/rss.xml" lisp) ;; lisp project of the day
                       ("https://ambrevar.xyz/atom.xml" lisp) ;; lisper, maker of nyxt browser
                       ("https://alhassy.github.io/rss.xml" lisp) ;; lisper, had that great post about emacs lisp's type system
                       ("https://www.reddit.com/r/dailyprogrammer/.rss" daily)
                       ("http://understandinguncertainty.org/blog" infrequent)
                       ("http://timharford.com/feed/" econ)
                       ("https://www.bennee.com/~alex/blog/feeds/all.atom.xml" infrequent)
                       ("https://sive.rs/podcast.rss" infrequent)
                       ("https://jack-clark.net/feed/" ai tech)
                       ("https://lacker.io/feed.xml" ai tech)
                       ("https://graymirror.substack.com/feed" leftist))))
#+end_src
