#+TITLE: Emacs Configuration
#+AUTHOR: Liam Packer

So this is the config. Trying out an org-babel-load'ed config now to
see how I like it.

* Melpa + usepackage
  Going to need melpa so lets just get that out of the way
  #+BEGIN_SRC emacs-lisp
  (require 'package)
  (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  ;;(add-to-list 'package-archives (cons "melpa-stable" (concat proto "://stable.melpa.org/packages/")) t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives '("gnu" . (concat proto "://elpa.gnu.org/packages/")))))
(package-initialize)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
  ;; chicken before the
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-verbose t)
  (setq use-package-always-ensure t)
  #+END_SRC

  We also have to boostrap use-package because of reason, so that's
  next
  #+BEGIN_SRC emacs-lisp
  ;; chicken before the
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-verbose t)
  (setq use-package-always-ensure t)
  #+END_SRC

* Annoying Defaults
  Going to just go ahead and do the following switches

  * turn of backups
  * turn off autosaves + change its directory
  * inhibit startup
  * get rid of scratch message
  * ... idk more shit
  #+BEGIN_SRC emacs-lisp
  (setf backup-inhibited t
        auto-save-default nil
        auto-save-list-file-prefix (locate-user-emacs-file "local/saves")
        inhibit-startup-message t
        initial-scratch-message nil
        wdired-allow-to-change-permissions t
        echo-keystrokes 0.1
        delete-active-region nil
        disabled-command-function nil
        custom-file (make-temp-file "emacs-custom")
        large-file-warning-threshold 536870911
        gc-cons-threshold (* 1024 1024 32)
        ring-bell-function (lambda ()))
  #+END_SRC

  Turn off menubar and GUI, blinking cursor, electric indenting,
  scrollbarmode, y-or-n-p, encoding system, inserting
  #+BEGIN_SRC emacs-lisp
  ;; GUIs are for newbs
  (menu-bar-mode -1)
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

  ;; Too distracting
  (blink-cursor-mode -1)

  ;; Don't jerk me around
  (electric-indent-mode -1)

  ;; I never want to use this
  (when (fboundp 'set-horizontal-scroll-bar-mode)
    (set-horizontal-scroll-bar-mode nil))

  ;; I hate typing
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; Always use the one true encoding
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)

  ;; Insert key is stupid
  (define-key global-map [(insert)] nil)
  (define-key global-map [(control insert)] 'overwrite-mode)

  ;; I hate hitting this by accident
  (global-set-key (kbd "C-<up>") #'previous-line)
  (global-set-key (kbd "C-<down>") #'next-line)

  ;; Magit is the only front-end I care about
  (setf vc-handled-backends nil
        vc-follow-symlinks t)

  ;; Stop scrolling by huge leaps
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))
        scroll-conservatively most-positive-fixnum
        scroll-preserve-screen-position t)
                                          ;(global-set-key (kbd "M-n") (kbd "C-u 1 C-v"))

  ;; fill-column at 80 is the CS dept standard
  ;; Fill column + always show column
  (setq fill-column 80)
  (setq fci-rule-column 80)
  (setq column-number-mode t)

  ;; fuck cursor lagging on moving
  (setq auto-window-vscroll nil)

  #+END_SRC

  I like to have paren-mode matching as 'parenthesis value. Also
  compilation configuration
  #+BEGIN_SRC emacs-lisp
  ;; paren mode matching
  (show-paren-mode t)
  (setq show-paren-style 'parenthesis)

  ;; I'd prefer that compilation output goes to *compilation buffer*
  ;; Rarely have the window selected, so the output disappears past the
  ;; bottom of the window
  (setq compilation-scroll-output t)
  (setq compilation-window-height 15)
  #+END_SRC

  archaic default storage values are dissapointing as defaults
  too. Time to waste space it's the future
  #+BEGIN_SRC emacs-lisp
  ;; quicktramp setup
  (setq tramp-default-method "ssh")
  (setq enable-recursive-minibuffers t)


    ;; Create own directory for ~ backup file clutter
    (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))

    ;; Disk space is cheap. Save lots.
    (setq delete-old-versions -1)
    (setq version-control t)
    (setq vc-make-backup-files t)
    (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

    ;; we don't live in the past. bump that memory up.
    (setq gc-cons-threshold 50000000)
  #+END_SRC

  Also look for executables in bins
  #+BEGIN_SRC emacs-lisp
  (setq exec-path (append exec-path '("/user/local/bin" "~/bin")))

  #+END_SRC

  I hate tabs and lets actually indent whenever we do a newline. Cmon
  bruh
  #+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (delete-selection-mode)
  (global-set-key (kbd "RET") 'newline-and-indent)
  #+END_SRC

* Useful Defuns + Keybinds
** Defuns + Corresponding Keybinds
*** Misc
    I don't really want emacs telling me I'm killing the current
    buffer. I know I am. It's kind of hard to do by accident.
    #+BEGIN_SRC emacs-lisp
    (defun lp/kill-current-buffer ()
      "Just kill the gd buffer"
      (interactive)
      (kill-buffer (current-buffer)))

    (global-set-key (kbd "C-x k") 'lp/kill-current-buffer)
    #+END_SRC

    I also like to be able to make scratch buffers on command, so
    that's something I have now. Also change the mode of these random
    scratch buffers to elisp mode because that's usually what they're for.
    #+BEGIN_SRC emacs-lisp
    (defun lp/generate-scratch-buffer ()
      "Generate random scratch buffer for whatever reason"
      (interactive)
      (switch-to-buffer (make-temp-name "scratch-"))
      (emacs-lisp-mode))

    (global-set-key (kbd "<f12>") 'lp/generate-scratch-buffer)
    #+END_SRC

    This one is fun. Evaluate the sexp at point and replace it with its
    value. This comes in handy every once in a while since it can
    happen anywhere
    #+BEGIN_SRC emacs-lisp
    (defun eval-and-replace (value)
      "Evalute the sexp at point and replace it with its value"
      (interactive (list (eval-last-sexp nil)))
      (kill-sexp -1)
      (insert (format "%S" value)))

    (global-set-key (kbd "C-c C-e") #'eval-and-replace)
    #+END_SRC

    This one adjusts a window width to the perfect column 80! WOw.
    #+BEGIN_SRC emacs-lisp
    (defun set-80-columns ()
      "Set the selected window to 80 columns. If given a prefix
    argument, set so that number of columns instead."
      (interactive)
      (set-window-width (or current-prefix-arg 80)))

    (global-set-key (kbd "C-x ~") #'set-80-columns)
    #+END_SRC
*** File input
    A couple of good ones here. Pulls the contents of the file as a
    string to manipulate. The rest allow for a scratch buffer in the
    respective mode. Quite nice.
    #+BEGIN_SRC emacs-lisp
    (defun slurp (file)
      "Return FILE contents as a string."
      (with-temp-buffer
        (insert-file-contents file)
        (buffer-string)))

    ;; Quick switch to scratch buffers

    (defmacro scratch-key (key buffer-name mode)
      `(global-set-key ,key (lambda ()
                              (interactive)
                              (switch-to-buffer ,buffer-name)
                              (unless (eq major-mode ',mode)
                                (,mode)))))

    (declare-function js2-mode nil)
    (declare-function clojure-mode nil)
    (scratch-key (kbd "C-c s") "*scratch*"    emacs-lisp-mode)
    (scratch-key (kbd "C-c j") "*javascript*" js2-mode)
    (scratch-key (kbd "C-c x") "*css*"        css-mode)
    (scratch-key (kbd "C-c h") "*html*"       html-mode)
    #+END_SRC


    This one opens all files and sub-dirs below the given directory.
    #+BEGIN_SRC emacs-lisp
    ;; ID: 72dc0a9e-c41c-31f8-c8f5-d9db8482de1e
    (defun find-all-files (dir)
      "Open all files and sub-directories below the given directory."
      (interactive "DBase directory: ")
      (let* ((list (directory-files dir t "^[^.]"))
             (files (cl-remove-if 'file-directory-p list))
             (dirs (cl-remove-if-not 'file-directory-p list)))
        (dolist (file files)
          (find-file-noselect file))
        (dolist (dir dirs)
          (find-file-noselect dir)
          (find-all-files dir))))
    #+END_SRC

*** indentation
    indent region or buffer!
    #+BEGIN_SRC emacs-lisp
      ;; prelude-core.el
      (defun indent-buffer ()
        "Indent the currently visited buffer."
        (interactive)
        (indent-region (point-min) (point-max)))

      ;; prelude-editing.el
      (defcustom prelude-indent-sensitive-modes
        '(coffee-mode python-mode slim-mode haml-mode yaml-mode)
        "Modes for which auto-indenting is suppressed."
        :type 'list)

      (defun indent-region-or-buffer ()
        "Indent a region if selected, otherwise the whole buffer."
        (interactive)
        (unless (member major-mode prelude-indent-sensitive-modes)
          (save-excursion
            (if (region-active-p)
                (progn
                  (indent-region (region-beginning) (region-end))
                  (message "Indented selected region."))
              (progn
                (indent-buffer)
                (message "Indented buffer.")))
            (whitespace-cleanup))))

      (global-set-key (kbd "C-c n") 'indent-region-or-buffer)
    #+END_SRC
** Keybinds
   Sometimes I get lazy and just move around with ~C-u C-p~ or
   something, so this lets me do it a little better.
   #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "M-p") (kbd "C-u 1 M-v"))
   (global-set-key (kbd "C-S-p") (lambda ()
                                   (interactive)
                                   (previous-line 3)))
   (global-set-key (kbd "C-S-n") (lambda ()
                                   (interactive)
                                   (next-line 3)))
   #+END_SRC

   I love the pop-mark commands, so that's what this one does.
   #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-x p") 'pop-to-mark-command)
   (setq set-mark-command-repeat-pop t)
   (setq global-mark-ring-max 50000)
   #+END_SRC

   Hippe expand is nice, im a fan. I also like having eval-buffer
   ready on a keybind to make things easier. Need to find a better
   command for compile, but this is here too.
   #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "M-/") 'hippie-expand)
   (global-set-key (kbd "C-c C-k") #'eval-buffer)
   (global-set-key (kbd "C-<f7>") 'compile)
   (global-set-key (kbd "<f5>") #'revert-buffer)
   #+END_SRC

   I like a quick comment and uncomment region.
   #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-;") 'comment-or-uncomment-region)
   #+END_SRC

*** which-key if i get lost

    #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :ensure t
      :config (which-key-mode 1))
    #+END_SRC
* Aesthetics
** misc
   global visual line mode, prettify and bell function outta here.
   #+BEGIN_SRC emacs-lisp
   ;; wrap visual lines! it helps.
   (global-visual-line-mode 1)

   ;; Fancy lambdas
   (global-prettify-symbols-mode t)

   ;; screw the bell
   (setq ring-bell-function 'ignore)
   #+END_SRC

   Soft highlight of the line since it's nice.
   #+BEGIN_SRC emacs-lisp
   (when window-system
     (global-hl-line-mode))
   #+END_SRC

** Fonts
   A bunch of font functionality to give that doesn't really exist in
   vanilla emacs afaik.
   #+BEGIN_SRC emacs-lisp
   ;; iosevka, consolas, source code pro, Fira Code, dejavu, IBM 3270,
   ;; Fantasque Sans Mono, Terminus
   (setq lp/default-font "Courier New")

   (setq lp/default-font-size 12)

   (setq lp/current-font-size lp/default-font-size)

   ;; Define the factor that we should go by when increasing/decreasing
   (setq lp/font-change-increment 1.1)

   (defun lp/set-font-size ()
     "Set the font to 'lp/default-font' at 'lpcurrent-font-size'."
     (set-frame-font
      (concat lp/default-font "-" (number-to-string lp/current-font-size))))

   (defun lp/reset-font-size ()
     "Change font back to default size"
     (interactive)
     (setq lp/current-font-size lp/default-font-size)
     (lp/set-font-size))

   (defun lp/increase-font-size ()
     "increase current font size by a factor of 'lp/font-change-increment'."
     (interactive)
     (setq lp/current-font-size
           (ceiling (* lp/current-font-size lp/font-change-increment)))
     (lp/set-font-size))

   (defun lp/decrease-font-size ()
     (interactive)
     (setq lp/current-font-size
           (floor (/ lp/current-font-size lp/font-change-increment)))
     (lp/set-font-size))

   (define-key global-map (kbd "C-0") 'lp/reset-font-size)
   (define-key global-map (kbd "C-=") 'lp/increase-font-size)
   (define-key global-map (kbd "C--") 'lp/decrease-font-size)

   (lp/reset-font-size)
   #+END_SRC

** Diminish
   Diminish a bunch of default modes that clutter the modeline.
   #+BEGIN_SRC emacs-lisp
   ;;; Hide a whole bunch of stuff on the modeline. It's a bit annoying.
   ;;; Using the =diminish= package for this.
   (use-package diminish
     :ensure t
     :config
     (defmacro diminish-minor-mode (filename mode &optional abbrev)
       `(eval-after-load (symbol-name ,filename)
          '(diminish ,mode ,abbrev)))

     (defmacro diminish-major-mode (mode-hook abbrev)
       `(add-hook ,mode-hook
                  (lambda () (setq mode-name ,abbrev))))

     (diminish-minor-mode 'abbrev 'abbrev-mode)
     (diminish-minor-mode 'simple 'auto-fill-function)
     (diminish-minor-mode 'company 'company-mode)
     (diminish-minor-mode 'eldoc 'eldoc-mode)
     (diminish-minor-mode 'flycheck 'flycheck-mode)
     (diminish-minor-mode 'flyspell 'flyspell-mode)
     (diminish-minor-mode 'global-whitespace 'global-whitespace-mode)
     (diminish-minor-mode 'projectile 'projectile-mode)
     (diminish-minor-mode 'ruby-end 'ruby-end-mode)
     (diminish-minor-mode 'subword 'subword-mode)
     (diminish-minor-mode 'undo-tree 'undo-tree-mode)
     (diminish-minor-mode 'yard-mode 'yard-mode)
     (diminish-minor-mode 'yasnippet 'yas-minor-mode)
     (diminish-minor-mode 'wrap-region 'wrap-region-mode)
     (diminish-minor-mode 'simple 'visual-line-mode)
     (diminish-minor-mode 'paredit 'paredit-mode " π")
     (diminish-major-mode 'emacs-lisp-mode-hook "el")
     (diminish-major-mode 'haskell-mode-hook "λ=")
     (diminish-major-mode 'lisp-interaction-mode-hook "λ")
     (diminish-major-mode 'python-mode-hook "Py"))
   #+END_SRC

** Theme
   gotta get a good theme
   #+BEGIN_SRC emacs-lisp
     (use-package zenburn-theme
       :ensure t)
     (load-theme 'zenburn t)
   #+END_SRC
* Navigation
** Buffers
*** ibuffer
    always use ibuffer
    #+BEGIN_SRC emacs-lisp
   (defalias 'list-buffers 'ibuffer) ; always use ibuffer

    #+END_SRC

    always use ibuffer in another window
    #+BEGIN_SRC emacs-lisp
   ;; GROUP: Convenience -> Ibuffer
   (setq ibuffer-use-other-window t) ;; always display ibuffer in another window
    #+END_SRC

**** ibuffer-vc

     #+BEGIN_SRC emacs-lisp
   (use-package ibuffer-vc
     :ensure t)
   (add-hook 'ibuffer-hook
             (lambda ()
               (ibuffer-vc-set-filter-groups-by-vc-root)
               (unless (eq ibuffer-sorting-mode 'alphabetic)
                 (ibuffer-do-sort-by-alphabetic))))

   (setq ibuffer-formats
         '((mark modified read-only vc-status-mini " "
                 (name 18 18 :left :elide)
                 " "
                 (size 9 -1 :right)
                 " "
                 (mode 16 16 :left :elide)
                 " "
                 (vc-status 16 16 :left)
                 " "
                 filename-and-process)))
     #+END_SRC
** windows
   standard windows configuration to not have cancer
   #+BEGIN_SRC emacs-lisp
     ;; Buffer, Windows and Frames
     (setq
      frame-resize-pixelwise t               ; Resize by pixels
      frame-title-format
      '(:eval (if (buffer-file-name)
                  (abbreviate-file-name (buffer-file-name)) "%b"))
      ;; Size new windows proportionally wrt other windows
      window-combination-resize t)


     ;; I almost always want to switch to a window when I split. So lets do that.

     (defun lp/split-window-below-and-switch ()
       "Split window horizontally, then switch to that new window"
       (interactive)
       (split-window-below)
       (balance-windows)
       (other-window 1))

     (defun lp/split-window-right-and-switch ()
       "Split the window vertically, then switch to the new pane."
       (interactive)
       (split-window-right)
       (balance-windows)
       (other-window 1))

     (global-set-key (kbd "C-x 2") 'lp/split-window-below-and-switch)
     (global-set-key (kbd "C-x 3") 'lp/split-window-right-and-switch)
   #+END_SRC
*** ace-window
    better window navigation
    #+BEGIN_SRC emacs-lisp
      ;; ace-window stuff
      ;; You can also start by calling ace-window and then decide to switch the action to delete or swap etc. By default the bindings are:
      ;;     x - delete window
      ;;     m - swap windows
      ;;     M - move window
      ;;     j - select buffer
      ;;     n - select the previous window
      ;;     u - select buffer in the other window
      ;;     c - split window fairly, either vertically or horizontally
      ;;     v - split window vertically
      ;;     b - split window horizontally
      ;;     o - maximize current window
      ;;     ? - show these command bindings

      (use-package ace-window
        :ensure t
        :bind ("M-o" . ace-window)
        :config
        (setq  aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
    #+END_SRC

* Development
** Helm (trying this out now)
   holy helm

   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :ensure t
       :config
       (require 'helm-config)
       (global-set-key (kbd "C-c h") 'helm-command-prefix)
       (global-unset-key (kbd "C-x c"))
       (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
             helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
             helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
             helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
             helm-ff-file-name-history-use-recentf t
             helm-echo-input-in-header-line t)

        ;; helm is a little much for me
       (setq helm-autoresize-max-height 0)
       (setq helm-autoresize-min-height 20)
       (helm-autoresize-mode 1)

       (helm-mode 1)

       ;; going to want to use M-x with helm's powerful interface
       (global-set-key (kbd "M-x") 'helm-M-x)

       ;; We also are going to want to use the kill-ring feature
       (global-set-key (kbd "M-y") 'helm-show-kill-ring)

       ;; helm also has a great interface to a number of
       ;; different buffers and stuff like that
       (global-set-key (kbd "C-x b") 'helm-mini)

       ;; Another place to stick helm in. fuzzy matching,
       (global-set-key (kbd "C-x C-f") 'helm-find-files)

       ;; We also want helm-occur to not be on a horrible keybind
       (global-set-key (kbd "C-c h o") 'helm-occur)

       ;; REGISTERS!
       (global-set-key (kbd "C-c h x") 'helm-register)
       )
   #+END_SRC
** eldoc
   eldoc helps to look whatever with emacs lisp shit
   #+BEGIN_SRC emacs-lisp
     (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
     (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
     (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
   #+END_SRC
** Editing
*** Volatile Highlight
    This package highlights changes to the buffer caused by commands
    like yanks, undos, and kills. The highlight dissapears after the
    next command.
    #+BEGIN_SRC emacs-lisp
    (use-package volatile-highlights
      :ensure t
      :config (volatile-highlights-mode t))
    #+END_SRC

*** Smartparens
    Trying this out for a little. It isn't quite paredit, but we don't
    really want paredit for when we want smartparens so that's a thing
    I guess.

    #+BEGIN_SRC emacs-lisp
    (use-package smartparens
      :ensure t
      :config
      (setq sp-base-key-bindings 'paredit)
      (setq sp-autoskip-closing-pair 'always)
      (setq sp-hybrid-kill-entire-symbol nil)
      (sp-use-paredit-bindings))
    #+END_SRC
*** Yasnippet
    Yasnippet is good shit. I like it. Let's keep it poppin
    #+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :functions yas-global-mode yas-expand
      :diminish yas-minor-mode
      :config
      (yas-global-mode 1)
      (setq yas-fallback-behavior 'return-nil)
      (setq yas-triggers-in-field t)
      (setq yas-verbosity 0)
      (yas-reload-all))


    (use-package yasnippet-snippets
      :ensure t
      :after yasnippet
      :config
      (yas-reload-all))

    ;; Apparently the company-yasnippet backend shadows all backends that
    ;; come after it. To work around this we assign yasnippet to a different
    ;; keybind since actual source completion is vital.
    ;; (use-package company-yasnippet
    ;;   :ensure t
    ;;   :bind ("C-M-y" . company-yasnippet)
    ;;   :after (yasnippet))

    ;; auto yas is pretty damn cool
    (use-package auto-yasnippet
      :ensure t
      :bind ((  "C-1" . aya-create)
             (  "C-2" . aya-expand)))
    #+END_SRC
*** Hippie Expand


    ;; GROUP: Convenience -> Hippe Expand
    ;; hippie-expand is a better version of dabbrev-expand.
    ;; While dabbrev-expand searches for words you already types, in current;; buffers and other buffers, hippie-expand includes more sources,
    ;; such as filenames, klll ring...
    #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-/") 'hippie-expand) ;; replace dabbrev-expand
    (setq
     hippie-expand-try-functions-list
     '(try-expand-dabbrev ;; Try to expand word "dynamically", searching the current buffer.
       try-expand-dabbrev-all-buffers ;; Try to expand word "dynamically", searching all other buffers.
       try-expand-dabbrev-from-kill ;; Try to expand word "dynamically", searching the kill ring.
       try-complete-file-name-partially ;; Try to complete text as a file name, as many characters as unique.
       try-complete-file-name ;; Try to complete text as a file name.
       try-expand-all-abbrevs ;; Try to expand word before point according to all abbrev tables.
       try-expand-list ;; Try to complete the current line to an entire line in the buffer.
       try-expand-line ;; Try to complete the current line to an entire line in the buffer.
       try-complete-lisp-symbol-partially ;; Try to complete as an Emacs Lisp symbol, as many characters as unique.
       try-complete-lisp-symbol) ;; Try to complete word as an Emacs Lisp symbol.
     )
    #+END_SRC
*** indenting
*** expand-region
    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :ensure t
        :config
        (global-set-key (kbd "C-c n") 'er/expand-region))
    #+END_SRC
*** misc
    Kill region kills only a line if nothing active. acts as ~dd~ from
    vim!
    #+BEGIN_SRC emacs-lisp
    (defadvice kill-region (before slick-cut activate compile)
      "When called interactively with no active region, kill a single
    line instead."
      (interactive
       (if mark-active (list (region-beginning) (region-end))
         (list (line-beginning-position)
               (line-beginning-position 2)))))
    #+END_SRC
* Files
** Dired  
*** wdired
*** dired+
    dired+ has a LOT of extra features that we will not be going into
    here. just the faces are a good addition.


    (require dired+)


*** recentf
    recentf is good stuff. we'll need it
    #+BEGIN_SRC emacs-lisp
      (use-package recentf
        :ensure t
        :config
        (recentf-mode)
        (setq
         recentf-max-menu-items 15
         recentf-max-saved-items 200
         recentf-auto-cleanup 300
            recentf-exclude (list "/\\.git/.*\\'"     ; Git contents
                               "/elpa/.*\\'"       ; Package files
                               "/itsalltext/"      ; It's all text temp files
                               ;; And all other kinds of boring files
                               #'ignoramus-boring-p)))
    #+END_SRC
*** ztree
    cute tree navigation of file systems
    #+BEGIN_SRC emacs-lisp
      (use-package ztree
        :ensure t)
    #+END_SRC
*** vlf
    very large files. dangerous. we'll need help with that
    #+BEGIN_SRC emacs-lisp
      (use-package vlf
        :ensure t
        :config
        (setq vlf-application 'dont-ask) ; please don't ask wehn you open a big file
        )
    #+END_SRC
* External
** Flyspell
   flyspell to make sure we're actually spelling things correctly. can be a bit tedious
   #+BEGIN_SRC emacs-lisp
      ;; GROUP: Processes -> Flyspell
     (if (executable-find "aspell")
         (progn
           (setq ispell-program-name "aspell")
           (setq ispell-extra-args '("--sug-mode=ultra")))
       (setq ispell-program-name "ispell"))

     (add-hook 'text-mode-hook 'flyspell-mode)
     (add-hook 'org-mode-hook 'flyspell-mode)
     (add-hook 'prog-mode-hook 'flyspell-prog-mode)

   #+END_SRC

** Term mode stuff
   Term mode is kind of a dousy so here are some keybinds to not want to end myself
   #+BEGIN_SRC emacs-lisp
     ;; term-mode, used in M-x term
     (defun my-term-setup ()
       (interactive)
       (define-key term-raw-map (kbd "C-y") 'term-send-raw)
       (define-key term-raw-map (kbd "C-p") 'term-send-raw)
       (define-key term-raw-map (kbd "C-n") 'term-send-raw)
       (define-key term-raw-map (kbd "C-s") 'term-send-raw)
       (define-key term-raw-map (kbd "C-r") 'term-send-raw)
       (define-key term-raw-map (kbd "M-w") 'kill-ring-save)
       (define-key term-raw-map (kbd "M-y") 'helm-show-kill-ring)
       (define-key term-raw-map (kbd "M-d") (lambda () (interactive) (term-send-raw-string "\ed")))
       (define-key term-raw-map (kbd "<C-backspace>") (lambda () (interactive) (term-send-raw-string "\e\C-?")))
       (define-key term-raw-map (kbd "M-p") (lambda () (interactive) (term-send-raw-string "\ep")))
       (define-key term-raw-map (kbd "M-n") (lambda () (interactive) (term-send-raw-string "\en")))
       (define-key term-raw-map (kbd "M-,") 'term-send-input)
       (define-key term-raw-map (kbd "C-c y") 'term-paste)
       (define-key term-raw-map (kbd "C-S-y") 'term-paste)
       (define-key term-raw-map (kbd "C-h") nil) ; unbind C-h
       (define-key term-raw-map (kbd "M-x") nil) ; unbind M-x
       (define-key term-raw-map (kbd "C-c C-b") 'helm-mini)
       (define-key term-raw-map (kbd "C-1") 'zygospore-toggle-delete-other-windows)
       (define-key term-raw-map (kbd "C-2") 'split-window-below)
       (define-key term-raw-map (kbd "C-3") 'split-window-right)
       (define-key term-mode-map (kbd "C-0") 'delete-window))
     (add-hook 'term-mode-hook 'my-term-setup t)
     (setq term-buffer-maximum-size 0)

     (require 'term)

     ;; taken from here: http://www.enigmacurry.com/2008/12/26/emacs-ansi-term-tricks/
     (defun visit-ansi-term ()
       "If the current buffer is:
          1) a running ansi-term named *ansi-term*, rename it.
          2) a stopped ansi-term, kill it and create a new one.
          3) a non ansi-term, go to an already running ansi-term
             or start a new one while killing a defunt one"
       (interactive)
       (let ((is-term (string= "term-mode" major-mode))
             (is-running (term-check-proc (buffer-name)))
             (term-cmd "/bin/zsh")
             (anon-term (get-buffer "*ansi-term*")))
         (if is-term
             (if is-running
                 (if (string= "*ansi-term*" (buffer-name))
                     ;; (call-interactively 'rename-buffer)
                     (ansi-term term-cmd)
                   (if anon-term
                       (switch-to-buffer "*ansi-term*")
                     (ansi-term term-cmd)))
               (kill-buffer (buffer-name))
               (ansi-term term-cmd))
           (if anon-term
               (if (term-check-proc "*ansi-term*")
                   (switch-to-buffer "*ansi-term*")
                 (kill-buffer "*ansi-term*")
                 (ansi-term term-cmd))
             (ansi-term term-cmd)))))

     (global-set-key (kbd "<f2>") 'visit-ansi-term)
   #+END_SRC
* Programming
** C/C++
   some basic setup for C mode stuff. There are number of different
   styles we can choose from for the default, so we'll be using linux
  #+BEGIN_SRC emacs-lisp
    ;; Available C style:
    ;; “gnu”: The default style for GNU projects
    ;; “k&r”: What Kernighan and Ritchie, the authors of C used in their book
    ;; “bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
    ;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
    ;; “stroustrup”: What Stroustrup, the author of C++ used in his book
    ;; “ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
    ;; “linux”: What the Linux developers use for kernel development
    ;; “python”: What Python developers use for extension modules
    ;; “java”: The default style for java-mode (see below)
    ;; “user”: When you want to define your own style
    (setq c-default-style "linux" ; set style to "linux"
          c-basic-offset 4)
    (add-hook 'c-mode-common-hook 'hs-minor-mode)
  #+END_SRC


  OOOOOoooo gdb i love it
  #+BEGIN_SRC emacs-lisp
    (setq gdb-many-windows t        ; use gdb-many-windows by default
          gdb-show-main t)          ; Non-nil means display source file containing the main routine at startup
  #+END_SRC

  

** python
*** elpy
   #+BEGIN_SRC emacs-lisp
     (use-package elpy
       :ensure t
       :defer t)
   #+END_SRC
*** standard python setup
    #+BEGIN_SRC emacs-lisp
      (use-package python
        :ensure t
        :defer t
        :mode ("\\.py\\'" . python-mode)
        :interpreter ("python" . python-mode)
        :config
        (elpy-enable)
        (setq python-indent-offsett 2))
    #+END_SRC
*** company-jedi
    #+BEGIN_SRC emacs-lisp
      (use-package company-jedi
        :ensure t
        :after python
        :init
        (defun my/python-mode-hook ()
          (add-to-list 'company-backends 'company-jedi))
        (add-hook 'python-mode-hook 'my/python-mode-hook)
        )

    #+END_SRC
** ediff
   ediff is good. self explanatory
   #+BEGIN_SRC emacs-lisp
     (setq ediff-diff-options "-w"
           ediff-split-window-function 'split-window-horizontally
           ediff-window-setup-function 'ediff-setup-windows-plain)
   #+END_SRC
** magit
   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t)
   #+END_SRC

   and also git-gutter to know what we haven't committed yet
   #+BEGIN_SRC emacs-lisp
     ;; More info here: [[https://github.com/syohex/emacs-git-gutter]]
     (use-package git-gutter ; TODO - git gutter keybinds, going to different hunks and staging only certain portions!
       :ensure t
       :diminish git-gutter-mode
       :config
       (global-git-gutter-mode +1))
   #+END_SRC

** flycheck
   flycheck helps to catch easy to find errors.
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :config
       (add-hook 'after-init-hook #'global-flycheck-mode))

     (use-package flycheck-tip
       :ensure t)

   #+END_SRC
** lisps
*** paredit
   #+BEGIN_SRC emacs-lisp
   (use-package paredit
     :ensure t)
   #+END_SRC
*** rainbow delimiters

    #+BEGIN_SRC emacs-lisp
    (use-package rainbow-delimiters
      :ensure t)
    #+END_SRC
*** hooks into pared+rainbows
    #+BEGIN_SRC emacs-lisp
      ;; We want all lispy languages to use =paredit-mode= and =rainbow-delimiters
      (setq lisp-mode-hooks
            '(clojure-mode-hook
              emacs-lisp-mode-hook
              lisp-mode-hook
              scheme-mode-hook)) ; can add more or whatever

      (dolist (hook lisp-mode-hooks)
        (add-hook hook (lambda ()
                         (paredit-mode)
                         (rainbow-delimiters-mode))))
    #+END_SRC

** iedit
   #+BEGIN_SRC emacs-lisp
   
   #+END_SRC
** aggressive-indent
   sometimes you want the indent to fight back
   #+BEGIN_SRC emacs-lisp
     (use-package aggressive-indent
       :ensure t
       :diminish aggressive-indent-mode
       :hook ((emacs-lisp-mode css-mode c-mode c++-mode sh-mode) . aggressive-indent-mode))
   #+END_SRC
* eshell
** Basic configuration
   #+BEGIN_SRC emacs-lisp
     (require 'eshell)
     (require 'em-alias)
     (require 'cl)

     ;; Advise find-file-other-window to accept more than one file
     (defadvice find-file-other-window (around find-files activate)
       "Also find all files within a list of files. This even works recursively."
       (if (listp filename)
           (loop for f in filename do (find-file-other-window f wildcards))
         ad-do-it))

     ;; In Eshell, you can run the commands in M-x
     ;; Here are the aliases to the commands.
     ;; $* means accepts all arguments.
     (eshell/alias "o" "")
     (eshell/alias "o" "find-file-other-window $*")
     (eshell/alias "vi" "find-file-other-window $*")
     (eshell/alias "vim" "find-file-other-window $*")
     (eshell/alias "emacs" "find-file-other-windpow $*")
     (eshell/alias "em" "find-file-other-window $*")

     (add-hook
      'eshell-mode-hook
      (lambda ()
        (setq pcomplete-cycle-completions nil)))

     ;; change listing switches based on OS
     (when (not (eq system-type 'windows-nt))
       (eshell/alias "ls" "ls --color -h --group-directories-first $*"))
   #+END_SRC
* Convenience
** Projectile  
   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :config
       (projectile-global-mode)
       (setq projectile-completion-system 'helm)
       (setq projectile-switch-project-action 'helm-projectile-find-file)
       (setq projectile-switch-project-action 'helm-projectile)
       (setq projectile-enable-caching t))
   #+END_SRC
* refiles
** TODO org - organize
   To-file later!
   #+BEGIN_SRC emacs-lisp
     (require 'use-package)
                                             ; org-mode
                                             ; TODO speed-keys?
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     (use-package org-bullets
       :ensure t
       :config
       (setq org-ellipsis "⤵"))

     (use-package org
       :ensure t
       :bind (("\C-cl" . org-store-link)
              ("\C-cl" . org-store-link)
              ("\C-cb" . org-iswitchb))
       :config
       (unbind-key "C-," org-mode-map) ;expand-region
       (unbind-key "C-m" org-mode-map) ;avy
       (add-hook 'org-mode-hook
                 (lambda ()
                   (org-bullets-mode t)))

       ;; use enter to follow links instead of C-c C-o
       (setq org-return-follows-link t)

       ;; NOTE: If this isn't working, make sure to delete /
       ;; byte-recompile the /elpa/org/.. directory!
       ;; enable language compiles
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((C . t)
          (python . t)
          (shell . t)
          (emacs-lisp . t)
          (gnuplot . t)
          (R . t)))
       (setq org-confirm-babel-evaluate nil)
       (setq org-M-RET-may-split-line nil)
       (setq org-src-fontify-natively t)
       (setq org-src-tab-acts-natively t)
       (setq org-edit-src-content-indentation 0)
       (setq org-src-window-setup 'current-window)


     ;;;;;;;; file directory setup
       ;; Org-capture management + Tasks
       (setq org-directory "~/Dropbox/org/")

       (defun org-file-path (filename)
         "Return absolute address of an org file give its relative name."
         (concat (file-name-as-directory org-directory) filename))

       (setq org-inbox-file "~/Dropbox/inbox.org")
       (setq org-index-file (org-file-path "index.org"))
       (setq org-personal-file (org-file-path "personal.org"))
       (setq org-school-file (org-file-path "school.org"))
       (setq org-projects-file (org-file-path "projects.org"))
       (setq org-journal-file (org-file-path "journal.org"))
       (setq org-monthly-file (org-file-path "monthly.org"))
       (setq org-archive-location
             (concat (org-file-path "archive.org") "::* From %s"))

       ;; I keep all of my todos in =~/Dropbox/org/index.org= so I derive my
       ;; agenda from there
       (setq org-agenda-files
             (list org-index-file org-personal-file org-school-file org-projects-file org-journal-file (org-file-path "to-read.org")))
       (setq all-org-files
             (list org-index-file org-personal-file org-school-file org-projects-file org-journal-file (org-file-path "to-read.org")))

       ;; refiling!
       ;; refiling
       ;; I like to look at pretty much just up to 3 levels of targets
       (setq org-refile-targets '((all-org-files :maxlevel . 3)))

       ;; only look at top level headings. Since org-mode represents
       ;; these as files, this also means that the highest level heading
       ;; will be the first "file" so to speak
       (setq org-refile-use-outline-path 'file)
       (setq org-outline-path-complete-in-steps nil)

       ;; allow creating new parents on refile
       (setq org-refile-allow-creating-parent-nodes 'confirm)
                                             ; todo stuff
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       (setq org-todo-keywords
             (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                     (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

       (setq org-todo-keyword-faces
             (quote (("TODO" :foreground "red" :weight bold)
                     ("NEXT" :foreground "DeepSkyBlue1" :weight bold)
                     ("DONE" :foreground "forest green" :weight bold)
                     ("WAITING" :foreground "orange" :weight bold)
                     ("HOLD" :foreground "magenta" :weight bold)
                     ("CANCELLED" :foreground "forest green" :weight bold)
                     ("MEETING" :foreground "forest green" :weight bold)
                     ("PHONE" :foreground "forest green" :weight bold))))

       (setq org-todo-state-tags-triggers
             (quote (("CANCELLED" ("CANCELLED" . t))
                     ("WAITING" ("WAITING" . t))
                     ("HOLD" ("WAITING") ("HOLD" . t))
                     (done ("WAITING") ("HOLD"))
                     ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                     ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                     ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))

       ;; Place tags close to the right-hand side of the window
       (add-hook 'org-finalize-agenda-hook 'place-agenda-tags)
       (defun place-agenda-tags ()
         "Put the agenda tags by the right border of the agenda window."
         (setq org-agenda-tags-column (- 4 (window-width)))
         (org-agenda-align-tags))
       ;; Changing a task state is done with C-c C-t KEY
       ;; where KEY is the appropriate fast todo state selection key as defined in org-todo-keywords.
       ;; The setting

       (setq org-use-fast-todo-selection t)

       ;; allows changing todo states with S-left and S-right skipping all of
       ;; the normal processing when entering or leaving a todo state. This
       ;; cycles through the todo states but skips setting timestamps and
       ;; entering notes which is very convenient when all you want to do is
       ;; fix up the status of an entry.
       (setq org-treat-S-cursor-todo-selection-as-state-change nil)
       (setq to-read-tags '(":learning:" ":books:" ":emacs:" ":research:" ":manga:" ":anime:"
                            ":ml:" ":sites:" ":games:" ":music:"))
       (defun lp/refile-to (file headline)
         "refile to specific spot (headline) in file"
         (let ((pos (save-excursion
                      (find-file file)
                      (org-find-exact-headline-in-buffer headline))))
           (org-refile nil nil (list headline file nil pos))))

       (defun lp/refile-to-file-with-tag (tag file headline)
         " Helper function to refile a group of tags to a certain file's headline"
         (while (not (equal nil (search-forward tag nil t)))
           (beginning-of-visual-line)
           (lp/refile-to file headline))
         (switch-to-buffer "index.org"))

       (defun lp/refile-school ()
         (lp/refile-to-file-with-tag ":school:" org-school-file "inbox"))

       (defun lp/refile-personal ()
         (lp/refile-to-file-with-tag ":personal:" org-personal-file "inbox"))

       (defun lp/refile-all-in-index ()
         (interactive)
         (beginning-of-buffer)
         (lp/refile-school)
         (beginning-of-buffer)
         (lp/refile-personal)
         (universal-argument) ;; universal argument is the C-u prefix!
         (save-some-buffers))

       (defun lp/refile-to-read ()
         " Invoke on headline of inbox in to-read.org. refiles all tagged entries to respective header"
         (interactive)
         ;; do for each tag in our "to-read" tags
         (dotimes (i (length to-read-tags))
           ;; Search forward until we can't anymore (no more items with this tag
           (let ((tag (nth i to-read-tags)))
             (save-excursion
               (while (not (equal nil (search-forward tag nil t)))
                 (beginning-of-visual-line)
                 (lp/refile-to (org-file-path "to-read.org") (substring tag 1 -1)))))
           ))


       ;;   (setq-default org-preview-latex-default-process 'dvisvgm
       ;;                 org-latex-packages-alist '(("" "tikz" t)
       ;;                                            ("american,siunitx,smartlabels" "circuitikz" t)
       ;;                                            ("" "mathtools" t))
       ;;                 org-latex-preview-ltxpng-directory (locate-user-emacs-file "Latex Previews/")
       ;;                 org-format-latex-options
       ;;                 '(:foreground default :background default :scale 1.7
       ;;                               :html-foreground "Black" :html-background "Transparent" :html-scale 1.0
       ;;                               :matchers ("begin" "$1" "$" "$$" "\\(" "\\["))
       ;;                 org-preview-latex-process-alist
       ;;                 '((dvisvgm :programs ("latex" "dvisvgm")
       ;;                            :description "dvi > svg"
       ;;                            :message "you need to install the programs: latex and dvisvgm."
       ;;                            :use-xcolor t
       ;;                            :image-input-type "dvi"
       ;;                            :image-output-type "svg"
       ;;                            :image-size-adjust (1.7 . 1.5)
       ;;                            :latex-compiler ("latex -interaction nonstopmode -output-directory %o %f")
       ;;                            :image-converter ("dvisvgm %f -n -b 1 -c %S -o %O"))
       ;;                   (imagemagick :programs ("latex" "convert")
       ;;                                :description "pdf > png"
       ;;                                :message "you need to install the programs: latex and imagemagick."
       ;;                                :use-xcolor t
       ;;                                :image-input-type "pdf"
       ;;                                :image-output-type "png"
       ;;                                :image-size-adjust (1.0 . 1.0)
       ;;                                :latex-compiler ("pdflatex -interaction nonstopmode -output-directory %o %f")
       ;;                                :image-converter ("convert -density %D -trim -antialias %f -quality 100 %O"))
       ;;                   (dvipng :programs ("latex" "dvipng")
       ;;                           :description "dvi > png"
       ;;                           :message "you need to install the programs: latex and dvipng."
       ;;                           :image-input-type "dvi"
       ;;                           :image-output-type "png"
       ;;                           :image-size-adjust (1.0 . 1.0)
       ;;                           :latex-compiler ("latex -interaction nonstopmode -output-directory %o %f")
       ;;                           :image-converter ("dvipng -fg %F -bg %B -D %D -T tight -o %O %f")))
       ;;                 org-format-latex-header
       ;;                 "\\documentclass{article}
       ;; \\usepackage[usenames]{color}
       ;; [PACKAGES]
       ;; [DEFAULT-PACKAGES]
       ;; \\pagestyle{empty}
       ;; \\setlength{\\textwidth}{\\paperwidth}
       ;; \\addtolength{\\textwidth}{-3cm}
       ;; \\setlength{\\oddsidemargin}{1.5cm}
       ;; \\addtolength{\\oddsidemargin}{-2.54cm}
       ;; \\setlength{\\evensidemargin}{\\oddsidemargin}
       ;; \\setlength{\\textheight}{\\paperheight}
       ;; \\addtolength{\\textheight}{-\\headheight}
       ;; \\addtolength{\\textheight}{-\\headsep}
       ;; \\addtolength{\\textheight}{-\\footskip}
       ;; \\addtolength{\\textheight}{-3cm}
       ;; \\setlength{\\topmargin}{1.5cm}
       ;; \\addtolength{\\topmargin}{-2.54cm}
       ;; \\tikzset{every picture/.style={color=fg}}")

       ;; NOTE(nox): Get different latex fragments for different themes
                                             ; agenda stuff
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       (setq org-agenda-tags-column 80)
       ;; Do not dim blocked tasks
       (setq org-agenda-dim-blocked-tasks nil)
       ;; Compact the block agenda view
       (setq org-agenda-compact-blocks t) ;; nil為加上分隔線，t為去掉
       ;; 用describe-char來查你想要的seperator char code
       (setq org-agenda-block-separator 45)

     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; NOX'S SHIT
       (defun nox/org-agenda-finalize ()
         ;; NOTE(nox): Reset project hierarchy builder helper variable
         (setq nox/org-agenda-first-project t)

         ;; NOTE(nox): Remove empty blocks
         (save-excursion
           (goto-char (point-min))
           (let ((prev (if (get-text-property (point-min) 'org-agenda-structural-header)
                           (point-min)
                         (next-single-property-change (point-min) 'org-agenda-structural-header)))
                 next)
             (while (and prev (/= prev (point-max)))
               (setq next
                     (or (next-single-property-change (next-single-property-change prev 'org-agenda-structural-header)
                                                      'org-agenda-structural-header)
                         (point-max)))
               (if (or (and (< next (point-max)) (< (count-lines prev next) 4))
                       (and (= next (point-max)) (< (count-lines prev next) 2)))
                   (delete-region prev next)
                 (setq prev next)))))

         ;; NOTE(nox): Turn root projects bold
         (save-excursion
           (while (search-forward (char-to-string ?\u200B) nil t)
             (add-face-text-property (line-beginning-position) (1+ (line-end-position)) '(:weight bold)))))
       ;; Custom functions to find the tasks that were done in a file for the past month
       (require 'calendar)

       (defun jtc-org-tasks-closed-in-month (&optional month year match-string)
         "Produces an org agenda tags view list of the tasks completed
     in the specified month and year. Month parameter expects a number
     from 1 to 12. Year parameter expects a four digit number. Defaults
     to the current month when arguments are not provided. Additional search
     criteria can be provided via the optional match-string argument "
         (interactive)
         (let* ((today (calendar-current-date))
                (for-month (or month (calendar-extract-month today)))
                (for-year  (or year  (calendar-extract-year today))))
           (org-tags-view nil
                          (concat
                           match-string
                           (format "+CLOSED>=\"[%d-%02d-01]\""
                                   for-year for-month)
                           (format "+CLOSED<=\"[%d-%02d-%02d]\""
                                   for-year for-month
                                   (calendar-last-day-of-month for-month for-year))))))

       (defun jtc-foo-tasks-last-month ()
         "Produces an org agenda tags view list of all the tasks completed
     last month with the Category Foo."
         (interactive)
         (let* ((today (calendar-current-date))
                (for-month (calendar-extract-month today))
                (for-year  (calendar-extract-year today)))
           (calendar-increment-month for-month for-year -1)
           (jtc-org-tasks-closed-in-month
            for-month for-year "+TODO=\"DONE\"")))

       ;; AGENDA
       (setq-default
        org-agenda-custom-commands
        '(("n" "Agenda"
           ((agenda ""
                    ((org-agenda-files (list org-index-file
                                             org-personal-file org-school-file
                                             org-projects-file org-journal-file
                                             org-monthly-file))
                     (org-agenda-skip-scheduled-if-deadline-is-shown t)))
            (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!-DONE-HOLD"
                       ((org-agenda-overriding-header "To-File Files (index.org)")
                        (org-tags-match-list-sublevels nil)
                        (org-agenda-files (list org-index-file))))
            (tags "cs73|cs87|research"
                  ((org-agenda-overriding-header "CS Work")
                   (org-tags-match-list-sublevels nil)
                   (org-agenda-files (list org-school-file))))
            (tags "jpns"
                  ((org-agenda-overriding-header "JPNS")
                   (org-tags-match-list-sublevels nil)
                   (org-agenda-files (list org-school-file))))
            (tags "kizuna|smash|outsiders"
                  ((org-agenda-overriding-header "Clubs")
                   (org-tags-match-list-sublevels nil)
                   (org-agenda-files (list org-school-file))))
            (tags-todo "-REFILE-CANCELLED-WAITING-HOLD/!-DONE-HOLD"
                       ((org-agenda-overriding-header "Personal Stuff")
                        (org-tags-match-list-sublevels nil)
                        (org-agenda-files (list org-personal-file))))))
          ("t" "To Read Stuff"
           ((tags-todo "music/!-DONE-HOLD"
                       ((org-agenda-overriding-header "Music")
                        (orgs-tags-match-list-sublevels nil)
                        (org-agenda-files (list (org-file-path "to-read.org")))))
            (tags-todo "anime/!-DONE-HOLD"
                       ((org-agenda-overriding-header "Anime")
                        (orgs-tags-match-list-sublevels nil)
                        (org-agenda-files (list (org-file-path "to-read.org")))))
            (tags-todo "sites/!-DONE-HOLD"
                       ((org-agenda-overriding-header "Sites ")
                        (orgs-tags-match-list-sublevels nil)
                        (org-agenda-files (list (org-file-path "to-read.org")))))
            (tags-todo "research/!-DONE-HOLD"
                       ((org-agenda-overriding-header "Research Papers")
                        (orgs-tags-match-list-sublevels nil)
                        (org-agenda-files (list (org-file-path "to-read.org")))))
            (tags-todo "manga/!-DONE-HOLD"
                       ((org-agenda-overriding-header "Manga")
                        (orgs-tags-match-list-sublevels nil)
                        (org-agenda-files (list (org-file-path "to-read.org")))))
            (tags-todo "learning/!-DONE-HOLD"
                       ((org-agenda-overriding-header "Things to Learn")
                        (orgs-tags-match-list-sublevels nil)
                        (org-agenda-files (list (org-file-path "to-read.org")))))
            (tags-todo "books-learning/!-DONE-HOLD-WAITING"
                       ((org-agenda-overriding-header "Books")
                        (orgs-tags-match-list-sublevels nil)
                        (org-agenda-files (list (org-file-path "to-read.org"))))))))
        org-agenda-span 'week
        org-agenda-prefix-format '((agenda . "  %?-12t% s")
                                   (todo   . "  ")
                                   (tags   . "  ")
                                   (search . "  "))
        org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled
        org-agenda-tags-todo-honor-ignore-options t
        org-agenda-clockreport-parameter-plist `(:link t :maxlevel 6 :fileskip0 t :compact t :narrow 100)
        org-agenda-dim-blocked-tasks nil
        org-agenda-block-separator ""
                                             ;   org-agenda-time-grid '((daily today require-timed) nil "......" "----------------")
        )
       ;; Custom agenda command definitions
                                             ; ((org-agenda-finalize-hook 'nox/org-agenda-finalize))
       (setq org-tags-match-list-sublevels t)



       ;; Function to skip tag
       ;; From http://stackoverflow.com/questions/10074016/org-mode-filter-on-tag-in-agenda-view

       ;; Bind C-c C-x C-s to mark todo as done and archive it
       (defun lp/mark-done-and-archive ()
         "Mark the state of an org-mode item as DONE and archive it"
         (interactive)
         (org-todo 'done)
         (org-archive-subtree))


       (define-key org-mode-map (kbd "C-c C-x C-s") 'lp/mark-done-and-archive)
       (setq org-log-done 'time)             ; also record when the TODO was archived

       (setq org-capture-templates
             '(("g" "Groceries"
                entry
                (file "~/Dropbox/org/groceries.org")
                "- [ ] %?\n")
               ("i" "Ideas"
                entry
                (file+headline "~/Dropbox/org/ideas.org" "Project Ideas")
                "** [#%^{9}] %?\n")
               ("j" "Journal"
                entry
                (file+datetree "~/Dropbox/org/journal.org")
                "** %U :journal:\n%?")
               ("t" "to-read"
                entry
                (file+headline "~/Dropbox/org/to-read.org" "inbox")
                "** TODO %^{to-read}  %^g\n %U")
               ("z" "Todo"
                entry
                (file+headline org-index-file "Tasks")
                "* TODO %^{Task} %^G\n %U\n%?")
               ("p" "Personal todo"
                entry
                (file+headline org-personal-file "general")
                "* TODO %^{Task} %^g\n %?")))

     ;;; Org Keybindings
       ;; Useful keybinds
       (define-key global-map (kbd "C-c a") 'org-agenda)
       (define-key global-map (kbd "C-c c") 'org-capture)

       ;; Hit C-c i to open up my todo list.
       (defun lp/open-index-file ()
         "Open the org TODO list."
         (interactive)
         (find-file org-index-file)
         (flycheck-mode -1)
         (end-of-buffer))

       (global-set-key (kbd "C-c i") 'lp/open-index-file)

       (defun lp/org-capture-todo ()
         (interactive)
         (org-capture :keys "z"))

       (defun lp/open-full-agenda()
         (interactive)
         (org-agenda :keys "n")
         (delete-other-windows))

       (global-set-key (kbd "M-n") 'lp/org-capture-todo)
       (global-set-key (kbd "<f1>") 'lp/open-full-agenda)


       ;; Auto wrap paragraphs in some modes (auto-fill-mode)
       (add-hook 'text-mode-hook 'turn-on-auto-fill)
       (add-hook 'org-mode-hook 'turn-on-auto-fill)

       ;; sometimes i don't want to wrap text though, so we will toggle
       ;; with C-c q
       (global-set-key (kbd "C-c q") 'auto-fill-mode))
                                             ; clocking!
     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                             ; setup helpers

                                             ; ok back to clocking
     ;;;;;;;;;;;;;;;;;;;;

     ;; Resume clocking task when emacs is restarted
     (org-clock-persistence-insinuate)
     ;;
     ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
     (setq org-clock-history-length 23)
     ;; Resume clocking task on clock-in if the clock is open
     (setq org-clock-in-resume t)
     ;; Change tasks to NEXT when clocking in
     (setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
     ;; Separate drawers for clocking and logs
     (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
     ;; Save clock data and state changes and notes in the LOGBOOK drawer
     (setq org-clock-into-drawer t)
     ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
     (setq org-clock-out-remove-zero-time-clocks t)
     ;; Clock out when moving task to a done state
     (setq org-clock-out-when-done t)
     ;; Save the running clock and all clock history when exiting Emacs, load it on startup
     (setq org-clock-persist t)
     ;; Do not prompt to resume an active clock
     (setq org-clock-persist-query-resume nil)
     ;; Enable auto clock resolution for finding open clocks
     (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
     ;; Include current clocking task in clock reports
     (setq org-clock-report-include-clocking-task t)

   #+END_SRC

*** TODO research in org - organize - also pdftools
    #+BEGIN_SRC emacs-lisp
      ;; pdf-tools init
      ;; (use-package pdf-tools
      ;;   :ensure t
      ;;   :config
      ;;   (pdf-tools-install))

      ;; org-ref
      (use-package bibtex-utils
        :ensure t)

      (use-package biblio
        :ensure t)

      (use-package interleave
        :ensure t)
      ;;(require 'pubmed)
      ;;(require 'arxiv)
      ;;(require 'sci-id)

      (autoload 'helm-bibtex "helm-bibtex" "" t)

      (use-package org-ref

        :ensure t
        :config
        (require 'doi-utils)
        (setq org-ref-notes-directory "~/Dropbox/res"
              org-ref-bibliography-notes "~/Dropbox/res/notes.org"
              org-ref-default-bibliography '("~/Dropbox/res/index.bib")
              org-ref-pdf-directory "~/Dropbox/res/lib/"))

      (use-package helm-bibtex

        :ensure t
        :config
        (setq helm-bibtex-bibliography "~/Dropbox/res/index.bib" ;; where your references are stored
              helm-bibtex-library-path "~/Dropbox/res/lib/"
              bibtex-completion-library-path '("~/Dropbox/res/lib/") ;; where your pdfs etc are stored
              helm-bibtex-notes-path "~/Dropbox/res/notes.org" ;; where your notes are stored
              bibtex-completion-bibliography "~/Dropbox/res/index.bib" ;; completion
              bibtex-completion-notes-path "~/Dropbox/res/notes.org"))

      (defun lp/open-paper-notes ()
        "Open the org TODO list."
        (interactive)
        (find-file "~/Dropbox/res/notes.org")
        (flycheck-mode -1))
      (global-set-key  (kbd "C-c r") 'lp/open-paper-notes)
    #+END_SRC
** TODO elfeed - organize
 #+BEGIN_SRC emacs-lisp
   (use-package elfeed
     :ensure t
     :defer t
     :config
     (global-set-key (kbd "C-x w") 'elfeed)
     (setq shr-width 80)

     (setq-default elfeed-search-filter "@2-weeks-ago +unread ")

     (defun lp/elfeed-show-all ()
       (interactive)
       (bookmark-maybe-load-default-file)
       (bookmark-jump "elfeed-all"))
     (defun lp/elfeed-show-emacs ()
       (interactive)
       (bookmark-maybe-load-default-file)
       (bookmark-jump "elfeed-emacs"))
     (defun lp/elfeed-show-daily ()
       (interactive)
       (bookmark-maybe-load-default-file)
       (bookmark-jump "elfeed-daily"))

     ;; Entries older than 2 weeks are marked as readn
     (add-hook 'elfeed-new-entry-hook
               (elfeed-make-tagger :before "2 weeks ago"
                                   :remove 'unread))


     ;; code to add and remove a starred tag to elfeed article
     ;; based on http://matt.hackinghistory.ca/2015/11/22/elfeed/

     ;; add a star
     (defun bjm/elfeed-star ()
       "Apply starred to all selected entries."
       (interactive )
       (let* ((entries (elfeed-search-selected))
              (tag (intern "starred")))

         (cl-loop for entry in entries do (elfeed-tag entry tag))
         (mapc #'elfeed-search-update-entry entries)
         (unless (use-region-p) (forward-line))))

     ;; remove a start
     (defun bjm/elfeed-unstar ()
       "Remove starred tag from all selected entries."
       (interactive )
       (let* ((entries (elfeed-search-selected))
              (tag (intern "starred")))

         (cl-loop for entry in entries do (elfeed-untag entry tag))
         (mapc #'elfeed-search-update-entry entries)
         (unless (use-region-p) (forward-line))))

     ;; face for starred articles
     (defface elfeed-search-starred-title-face
       '((t :foreground "#f77"))
       "Marks a starred Elfeed entry.")

     (push '(starred elfeed-search-starred-title-face) elfeed-search-face-alist)
     (eval-after-load 'elfeed-search
       '(define-key elfeed-search-mode-map (kbd "*") 'bjm/elfeed-star))
     (eval-after-load 'elfeed-search
       '(define-key elfeed-search-mode-map (kbd "8") 'bjm/elfeed-unstar)))

   (use-package elfeed-org
     :ensure t
     :config
     (elfeed-org)
     (setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org")))
 #+END_SRC
** TODO hydra
** TODO writing
** TODO tex - organize
   #+BEGIN_SRC emacs-lisp
     (use-package tex-site                   ; AUCTeX initialization
       :ensure auctex)


     (use-package tex
       :defer t
       :ensure auctex
       :mode ("\\.tex\\'" . TeX-latex-mode)
       :config
       (setq TeX-PDF-mode t)

       (set-default 'preview-scale-function 2.0)

       ;; revert pdf-view after compilation
       (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
       (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
             TeX-source-correlate-start-server t
             TeX-source-correlate-mode t
             TeX-source-correlate-method 'synctex)
       (setq reftex-plug-into-AUCTeX t)
       (setq TeX-auto-save t)
       (setq TeX-parse-self t)
       (setq TeX-save-query nil)
       (setq TeX-view-program-list
             '(("Evince" "evince --page-index=%(outpage) %o")))
       (setq TeX-view-program-selection '((output-pdf "Evince")))
       (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
       (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
       (add-hook 'LaTeX-mode-hook 'flyspell-mode)
       (add-hook 'LaTeX-mode-hook 'flyspell-buffer)
       (add-hook 'LaTeX-mode-hook 'turn-on-reftex))

     (use-package tex-style                  ; TeX style
       :ensure auctex
       :defer t
       :config
       ;; Enable support for csquotes
       (setq LaTeX-csquotes-close-quote "}"
             LaTeX-csquotes-open-quote "\\enquote{"))

     (use-package tex-fold                   ; TeX folding
       :ensure auctex
       :defer t
       :init (add-hook 'TeX-mode-hook #'TeX-fold-mode))

     (use-package reftex                     ; TeX/BibTeX cross-reference management
       :defer t
       :init (add-hook 'LaTeX-mode-hook #'reftex-mode)
       :config
       ;; Plug into AUCTeX
       (setq reftex-plug-into-AUCTeX t
             ;; Automatically derive labels, and prompt for confirmation
             reftex-insert-label-flags '(t t)
             reftex-label-alist
             '(
               ;; Additional label definitions for RefTeX.
               ("definition" ?d "def:" "~\\ref{%s}"
                lunaryorn-reftex-find-ams-environment-caption
                ("definition" "def.") -3)
               ("theorem" ?h "thm:" "~\\ref{%s}"
                lunaryorn-reftex-find-ams-environment-caption
                ("theorem" "th.") -3)
               ("example" ?x "ex:" "~\\ref{%s}"
                lunaryorn-reftex-find-ams-environment-caption
                ("example" "ex") -3)
               ;; Algorithms package
               ("algorithm" ?a "alg:" "~\\ref{%s}"
                "\\\\caption[[{]" ("algorithm" "alg") -3)))

       ;; Provide basic RefTeX support for biblatex
       (unless (assq 'biblatex reftex-cite-format-builtin)
         (add-to-list 'reftex-cite-format-builtin
                      '(biblatex "The biblatex package"
                                 ((?\C-m . "\\cite[]{%l}")
                                  (?t . "\\textcite{%l}")
                                  (?a . "\\autocite[]{%l}")
                                  (?p . "\\parencite{%l}")
                                  (?f . "\\footcite[][]{%l}")
                                  (?F . "\\fullcite[]{%l}")
                                  (?x . "[]{%l}")
                                  (?X . "{%l}"))))
         (setq reftex-cite-format 'biblatex))
       :diminish reftex-mode)
   #+END_SRC

